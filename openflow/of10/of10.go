// Automatically generated by Packet Go code generator.
package of10

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"net"

	"github.com/packet/packet/src/go/packet"

	"github.com/soheilhy/beehive/openflow/of"
)

type Ports int

const (
	PP_MAX        Ports = 65280
	PP_IN_PORT    Ports = 65528
	PP_TABLE      Ports = 65529
	PP_NORMAL     Ports = 65530
	PP_FLOOD      Ports = 65531
	PP_ALL        Ports = 65532
	PP_CONTROLLER Ports = 65533
	PP_LOCAL      Ports = 65534
	PP_NONE       Ports = 65535
)

type Type int

const (
	PT_PACKET_IN                Type = 10
	PT_FLOW_REMOVED             Type = 11
	PT_PORT_STATUS              Type = 12
	PT_PACKET_OUT               Type = 13
	PT_FLOW_MOD                 Type = 14
	PT_PORT_MOD                 Type = 15
	PT_STATS_REQUEST            Type = 16
	PT_STATS_REPLY              Type = 17
	PT_BARRIER_REQUEST          Type = 18
	PT_BARRIER_REPLY            Type = 19
	PT_QUEUE_GET_CONFIG_REQUEST Type = 20
	PT_QUEUE_GET_CONFIG_REPLY   Type = 21
)

type ConfigFlags int

const (
	PC_FRAG_NORMAL ConfigFlags = 0
	PC_FRAG_DROP   ConfigFlags = 1
	PC_FRAG_REASM  ConfigFlags = 2
	PC_FRAG_MASK   ConfigFlags = 3
)

type Capabilities int

const (
	PC_FLOW_STATS   Capabilities = 1
	PC_TABLE_STATS  Capabilities = 2
	PC_PORT_STATS   Capabilities = 4
	PC_STP          Capabilities = 8
	PC_RESERVED     Capabilities = 16
	PC_IP_REASM     Capabilities = 32
	PC_QUEUE_STATS  Capabilities = 64
	PC_ARP_MATCH_IP Capabilities = 128
)

type PortConfig int

const (
	PPC_PORT_DOWN    PortConfig = 1
	PPC_NO_STP       PortConfig = 2
	PPC_NO_RECV      PortConfig = 4
	PPC_NO_RECV_STP  PortConfig = 8
	PPC_NO_FLOOD     PortConfig = 16
	PPC_NO_FWD       PortConfig = 32
	PPC_NO_PACKET_IN PortConfig = 64
)

type PortState int

const (
	PPS_LINK_DOWN   PortState = 1
	PPS_STP_LISTEN  PortState = 0
	PPS_STP_LEARN   PortState = 256
	PPS_STP_FORWARD PortState = 512
	PPS_STP_BLOCK   PortState = 768
	PPS_STP_MASK    PortState = 768
)

type PortFeatures int

const (
	PPF_10MB_HD    PortFeatures = 0
	PPF_10MB_FD    PortFeatures = 2
	PPF_100MB_HD   PortFeatures = 4
	PPF_100MB_FD   PortFeatures = 8
	PPF_1GB_HD     PortFeatures = 16
	PPF_1GB_FD     PortFeatures = 32
	PPF_10GB_FD    PortFeatures = 64
	PPF_COPPER     PortFeatures = 128
	PPF_FIBER      PortFeatures = 256
	PPF_AUTONEG    PortFeatures = 512
	PPF_PAUSE      PortFeatures = 1024
	PPF_PAUSE_ASYM PortFeatures = 2048
)

type PortReason int

const (
	PPR_ADD    PortReason = 0
	PPR_DELETE PortReason = 1
	PPR_MODIFY PortReason = 2
)

type PacketInReason int

const (
	PR_NO_MATCH PacketInReason = 0
	PR_ACTION   PacketInReason = 1
)

type ActionType int

const (
	PAT_OUTPUT       ActionType = 0
	PAT_SET_VLAN_VID ActionType = 1
	PAT_SET_VLAN_PCP ActionType = 2
	PAT_STRIP_VLAN   ActionType = 3
	PAT_SET_DL_SRC   ActionType = 4
	PAT_SET_DL_DST   ActionType = 5
	PAT_SET_NW_SRC   ActionType = 6
	PAT_SET_NW_DST   ActionType = 7
	PAT_SET_NW_TOS   ActionType = 8
	PAT_SET_TP_SRC   ActionType = 9
	PAT_SET_TP_DST   ActionType = 10
	PAT_ENQUEUE      ActionType = 11
	PAT_VENDOR       ActionType = 65535
)

type VlanIds int

const (
	P_VLAN_NONE VlanIds = 65535
)

type FlowModCommand int

const (
	PFC_ADD           FlowModCommand = 0
	PFC_MODIFY        FlowModCommand = 1
	PFC_MODIFY_STRICT FlowModCommand = 2
	PFC_DELETE        FlowModCommand = 3
	PFC_DELETE_STRICT FlowModCommand = 4
)

type FlowWildcards int

const (
	PFW_IN_PORT      FlowWildcards = 1
	PFW_DL_VLAN      FlowWildcards = 2
	PFW_DL_SRC       FlowWildcards = 4
	PFW_DL_DST       FlowWildcards = 8
	PFW_DL_TYPE      FlowWildcards = 16
	PFW_NW_PROTO     FlowWildcards = 32
	PFW_TP_SRC       FlowWildcards = 64
	PFW_TP_DST       FlowWildcards = 128
	PFW_NW_SRC_SHIFT FlowWildcards = 8
	PFW_NW_SRC_BITS  FlowWildcards = 5
	PFW_NW_SRC_MASK  FlowWildcards = 8
	PFW_NW_SRC_ALL   FlowWildcards = 8
	PFW_NW_DST_SHIFT FlowWildcards = 14
	PFW_NW_DST_BITS  FlowWildcards = 6
	PFW_NW_DST_MASK  FlowWildcards = 14
	PFW_NW_DST_ALL   FlowWildcards = 14
	PFW_DL_VLAN_PCP  FlowWildcards = 1048576
	PFW_NW_TOS       FlowWildcards = 2097152
	PFW_ALL          FlowWildcards = 4194303
)

type FlowModFlags int

const (
	PFF_SEND_FLOW_REM FlowModFlags = 1
	PFF_CHECK_OVERLAP FlowModFlags = 2
	PFF_EMERG         FlowModFlags = 4
)

type FlowRemovedReason int

const (
	PRR_IDLE_TIMEOUT FlowRemovedReason = 0
	PRR_HARD_TIMEOUT FlowRemovedReason = 1
	PRR_DELETE       FlowRemovedReason = 2
)

type ErrorType int

const (
	PET_HELLO_FAILED    ErrorType = 0
	PET_BAD_REQUEST     ErrorType = 1
	PET_BAD_ACTION      ErrorType = 2
	PET_FLOW_MOD_FAILED ErrorType = 3
	PET_PORT_MOD_FAILED ErrorType = 4
	PET_QUEUE_OP_FAILED ErrorType = 5
)

type HelloFailedCode int

const (
	PHFC_INCOMPATIBLE HelloFailedCode = 0
	PHFC_EPERM        HelloFailedCode = 1
)

type BadRequestCode int

const (
	PBRC_BAD_VERSION    BadRequestCode = 0
	PBRC_BAD_TYPE       BadRequestCode = 1
	PBRC_BAD_STAT       BadRequestCode = 2
	PBRC_BAD_VENDOR     BadRequestCode = 3
	PBRC_BAD_SUBTYPE    BadRequestCode = 4
	PBRC_EPERM          BadRequestCode = 5
	PBRC_BAD_LEN        BadRequestCode = 6
	PBRC_BUFFER_EMPTY   BadRequestCode = 7
	PBRC_BUFFER_UNKNOWN BadRequestCode = 8
)

type BadActionCode int

const (
	PBAC_BAD_TYPE        BadActionCode = 0
	PBAC_BAD_LEN         BadActionCode = 1
	PBAC_BAD_VENDOR      BadActionCode = 2
	PBAC_BAD_VENDOR_TYPE BadActionCode = 3
	PBAC_BAD_OUT_PORT    BadActionCode = 4
	PBAC_BAD_ARGUMENT    BadActionCode = 5
	PBAC_EPERM           BadActionCode = 6
	PBAC_TOO_MANY        BadActionCode = 7
	PBAC_BAD_QUEUE       BadActionCode = 8
)

type Flow_modFailedCode int

const (
	PFMFC_ALL_TABLES_FULL   Flow_modFailedCode = 0
	PFMFC_OVERLAP           Flow_modFailedCode = 1
	PFMFC_EPERM             Flow_modFailedCode = 2
	PFMFC_BAD_EMERG_TIMEOUT Flow_modFailedCode = 3
	PFMFC_BAD_COMMAND       Flow_modFailedCode = 4
	PFMFC_UNSUPPORTED       Flow_modFailedCode = 5
)

type Port_modFailedCode int

const (
	PPMFC_BAD_PORT    Port_modFailedCode = 0
	PPMFC_BAD_HW_ADDR Port_modFailedCode = 1
)

type QueueOpFailedCode int

const (
	PQC_BAD_PORT  QueueOpFailedCode = 0
	PQC_BAD_QUEUE QueueOpFailedCode = 1
	PQC_EPERM     QueueOpFailedCode = 2
)

type StatsTypes int

const (
	PST_DESC      StatsTypes = 0
	PST_FLOW      StatsTypes = 1
	PST_AGGREGATE StatsTypes = 2
	PST_TABLE     StatsTypes = 3
	PST_PORT      StatsTypes = 4
	PST_QUEUE     StatsTypes = 5
	PST_VENDOR    StatsTypes = 65535
)

type StatsReplyFlags int

const (
	PSF_REPLY_MORE StatsReplyFlags = 1
)

type DescStatsConstants int

const (
	SERIAL_NUM_LEN DescStatsConstants = 32
	DESC_STR_LEN   DescStatsConstants = 256
)

type QueueProperties int

const (
	PQT_NONE     QueueProperties = 0
	PQT_MIN_RATE QueueProperties = 1
)

func NewHeader10WithBuf(b []byte) Header10 {
	return Header10{of.Header{packet.Packet{Buf: b}}}
}

func NewHeader10() Header10 {
	s := 8
	b := make([]byte, s)
	p := Header10{of.Header{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type Header10 struct {
	of.Header
}

func (this Header10) minSize() int {
	return 8
}

func (this Header10) Clone() (Header10, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewHeader10(), err
	}

	return NewHeader10WithBuf(newBuf.Bytes()), nil
}

type Header10Conn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewHeader10Conn(c net.Conn) Header10Conn {
	return Header10Conn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *Header10Conn) Write(pkts []Header10) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *Header10Conn) Read(pkts []Header10) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewHeader10WithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *Header10) Init() {
	this.Header.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetVersion(uint8(1)) // version
}

func (this Header10) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToHeader10(p of.Header) (Header10, error) {
	if !IsHeader10(p) {
		return NewHeader10WithBuf(nil), errors.New("Cannot convert to of10.Header10")
	}

	return NewHeader10WithBuf(p.Buf), nil
}

func IsHeader10(p of.Header) bool {
	return p.Version() == 1 && true
}

func NewHelloWithBuf(b []byte) Hello {
	return Hello{of.Hello{of.Header{packet.Packet{Buf: b}}}}
}

func NewHello() Hello {
	s := 8
	b := make([]byte, s)
	p := Hello{of.Hello{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type Hello struct {
	of.Hello
}

func (this Hello) minSize() int {
	return 8
}

func (this Hello) Clone() (Hello, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewHello(), err
	}

	return NewHelloWithBuf(newBuf.Bytes()), nil
}

type HelloConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewHelloConn(c net.Conn) HelloConn {
	return HelloConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *HelloConn) Write(pkts []Hello) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *HelloConn) Read(pkts []Hello) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewHelloWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *Hello) Init() {
	this.Hello.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetVersion(uint8(1)) // version
	this.SetType(uint8(0))    // type
}

func (this Hello) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToHello(p of.Hello) (Hello, error) {
	if !IsHello(p) {
		return NewHelloWithBuf(nil), errors.New("Cannot convert to of10.Hello")
	}

	return NewHelloWithBuf(p.Buf), nil
}

func IsHello(p of.Hello) bool {
	return p.Version() == 1 && true
}

func NewEchoRequestWithBuf(b []byte) EchoRequest {
	return EchoRequest{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewEchoRequest() EchoRequest {
	s := 8
	b := make([]byte, s)
	p := EchoRequest{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type EchoRequest struct {
	Header10
}

func (this EchoRequest) minSize() int {
	return 8
}

func (this EchoRequest) Clone() (EchoRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewEchoRequest(), err
	}

	return NewEchoRequestWithBuf(newBuf.Bytes()), nil
}

type EchoRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewEchoRequestConn(c net.Conn) EchoRequestConn {
	return EchoRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *EchoRequestConn) Write(pkts []EchoRequest) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *EchoRequestConn) Read(pkts []EchoRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewEchoRequestWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *EchoRequest) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(2))    // type
	this.SetVersion(uint8(1)) // version
}

func (this EchoRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToEchoRequest(p Header10) (EchoRequest, error) {
	if !IsEchoRequest(p) {
		return NewEchoRequestWithBuf(nil), errors.New("Cannot convert to of10.EchoRequest")
	}

	return NewEchoRequestWithBuf(p.Buf), nil
}

func IsEchoRequest(p Header10) bool {
	return p.Type() == 2 && true
}

func NewEchoReplyWithBuf(b []byte) EchoReply {
	return EchoReply{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewEchoReply() EchoReply {
	s := 8
	b := make([]byte, s)
	p := EchoReply{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type EchoReply struct {
	Header10
}

func (this EchoReply) minSize() int {
	return 8
}

func (this EchoReply) Clone() (EchoReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewEchoReply(), err
	}

	return NewEchoReplyWithBuf(newBuf.Bytes()), nil
}

type EchoReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewEchoReplyConn(c net.Conn) EchoReplyConn {
	return EchoReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *EchoReplyConn) Write(pkts []EchoReply) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *EchoReplyConn) Read(pkts []EchoReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewEchoReplyWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *EchoReply) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(3))    // type
	this.SetVersion(uint8(1)) // version
}

func (this EchoReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToEchoReply(p Header10) (EchoReply, error) {
	if !IsEchoReply(p) {
		return NewEchoReplyWithBuf(nil), errors.New("Cannot convert to of10.EchoReply")
	}

	return NewEchoReplyWithBuf(p.Buf), nil
}

func IsEchoReply(p Header10) bool {
	return p.Type() == 3 && true
}

func NewFeaturesRequestWithBuf(b []byte) FeaturesRequest {
	return FeaturesRequest{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewFeaturesRequest() FeaturesRequest {
	s := 8
	b := make([]byte, s)
	p := FeaturesRequest{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FeaturesRequest struct {
	Header10
}

func (this FeaturesRequest) minSize() int {
	return 8
}

func (this FeaturesRequest) Clone() (FeaturesRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFeaturesRequest(), err
	}

	return NewFeaturesRequestWithBuf(newBuf.Bytes()), nil
}

type FeaturesRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFeaturesRequestConn(c net.Conn) FeaturesRequestConn {
	return FeaturesRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FeaturesRequestConn) Write(pkts []FeaturesRequest) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *FeaturesRequestConn) Read(pkts []FeaturesRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFeaturesRequestWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *FeaturesRequest) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(5))    // type
	this.SetVersion(uint8(1)) // version
}

func (this FeaturesRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFeaturesRequest(p Header10) (FeaturesRequest, error) {
	if !IsFeaturesRequest(p) {
		return NewFeaturesRequestWithBuf(nil), errors.New("Cannot convert to of10.FeaturesRequest")
	}

	return NewFeaturesRequestWithBuf(p.Buf), nil
}

func IsFeaturesRequest(p Header10) bool {
	return p.Type() == 5 && true
}

func NewGetConfigRequestWithBuf(b []byte) GetConfigRequest {
	return GetConfigRequest{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewGetConfigRequest() GetConfigRequest {
	s := 8
	b := make([]byte, s)
	p := GetConfigRequest{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type GetConfigRequest struct {
	Header10
}

func (this GetConfigRequest) minSize() int {
	return 8
}

func (this GetConfigRequest) Clone() (GetConfigRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewGetConfigRequest(), err
	}

	return NewGetConfigRequestWithBuf(newBuf.Bytes()), nil
}

type GetConfigRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewGetConfigRequestConn(c net.Conn) GetConfigRequestConn {
	return GetConfigRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *GetConfigRequestConn) Write(pkts []GetConfigRequest) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *GetConfigRequestConn) Read(pkts []GetConfigRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewGetConfigRequestWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *GetConfigRequest) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(7))    // type
	this.SetVersion(uint8(1)) // version
}

func (this GetConfigRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToGetConfigRequest(p Header10) (GetConfigRequest, error) {
	if !IsGetConfigRequest(p) {
		return NewGetConfigRequestWithBuf(nil), errors.New("Cannot convert to of10.GetConfigRequest")
	}

	return NewGetConfigRequestWithBuf(p.Buf), nil
}

func IsGetConfigRequest(p Header10) bool {
	return p.Type() == 7 && true
}

func NewSwitchGetConfigReplyWithBuf(b []byte) SwitchGetConfigReply {
	return SwitchGetConfigReply{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewSwitchGetConfigReply() SwitchGetConfigReply {
	s := 12
	b := make([]byte, s)
	p := SwitchGetConfigReply{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type SwitchGetConfigReply struct {
	Header10
}

func (this SwitchGetConfigReply) minSize() int {
	return 12
}

func (this SwitchGetConfigReply) Clone() (SwitchGetConfigReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewSwitchGetConfigReply(), err
	}

	return NewSwitchGetConfigReplyWithBuf(newBuf.Bytes()), nil
}

type SwitchGetConfigReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewSwitchGetConfigReplyConn(c net.Conn) SwitchGetConfigReplyConn {
	return SwitchGetConfigReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *SwitchGetConfigReplyConn) Write(pkts []SwitchGetConfigReply) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *SwitchGetConfigReplyConn) Read(pkts []SwitchGetConfigReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewSwitchGetConfigReplyWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *SwitchGetConfigReply) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(8))    // type
	this.SetVersion(uint8(1)) // version
}

func (this SwitchGetConfigReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToSwitchGetConfigReply(p Header10) (SwitchGetConfigReply, error) {
	if !IsSwitchGetConfigReply(p) {
		return NewSwitchGetConfigReplyWithBuf(nil), errors.New("Cannot convert to of10.SwitchGetConfigReply")
	}

	return NewSwitchGetConfigReplyWithBuf(p.Buf), nil
}

func IsSwitchGetConfigReply(p Header10) bool {
	return p.Type() == 8 && true
}

func (this *SwitchGetConfigReply) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchGetConfigReply) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this *SwitchGetConfigReply) FlagsOffset() int {
	offset := 8
	return offset
}

func (this *SwitchGetConfigReply) MissSendLen() uint16 {
	offset := this.MissSendLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchGetConfigReply) SetMissSendLen(m uint16) {
	offset := this.MissSendLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], m)
	offset += 2
}

func (this *SwitchGetConfigReply) MissSendLenOffset() int {
	offset := 10
	return offset
}

func NewSwitchSetConfigWithBuf(b []byte) SwitchSetConfig {
	return SwitchSetConfig{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewSwitchSetConfig() SwitchSetConfig {
	s := 12
	b := make([]byte, s)
	p := SwitchSetConfig{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type SwitchSetConfig struct {
	Header10
}

func (this SwitchSetConfig) minSize() int {
	return 12
}

func (this SwitchSetConfig) Clone() (SwitchSetConfig, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewSwitchSetConfig(), err
	}

	return NewSwitchSetConfigWithBuf(newBuf.Bytes()), nil
}

type SwitchSetConfigConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewSwitchSetConfigConn(c net.Conn) SwitchSetConfigConn {
	return SwitchSetConfigConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *SwitchSetConfigConn) Write(pkts []SwitchSetConfig) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *SwitchSetConfigConn) Read(pkts []SwitchSetConfig) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewSwitchSetConfigWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *SwitchSetConfig) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(9))    // type
	this.SetVersion(uint8(1)) // version
}

func (this SwitchSetConfig) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToSwitchSetConfig(p Header10) (SwitchSetConfig, error) {
	if !IsSwitchSetConfig(p) {
		return NewSwitchSetConfigWithBuf(nil), errors.New("Cannot convert to of10.SwitchSetConfig")
	}

	return NewSwitchSetConfigWithBuf(p.Buf), nil
}

func IsSwitchSetConfig(p Header10) bool {
	return p.Type() == 9 && true
}

func (this *SwitchSetConfig) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchSetConfig) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this *SwitchSetConfig) FlagsOffset() int {
	offset := 8
	return offset
}

func (this *SwitchSetConfig) MissSendLen() uint16 {
	offset := this.MissSendLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *SwitchSetConfig) SetMissSendLen(m uint16) {
	offset := this.MissSendLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], m)
	offset += 2
}

func (this *SwitchSetConfig) MissSendLenOffset() int {
	offset := 10
	return offset
}

func NewPhysicalPortWithBuf(b []byte) PhysicalPort {
	return PhysicalPort{packet.Packet{Buf: b}}
}

func NewPhysicalPort() PhysicalPort {
	s := 48
	b := make([]byte, s)
	p := PhysicalPort{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type PhysicalPort struct {
	packet.Packet
}

func (this PhysicalPort) minSize() int {
	return 48
}

func (this PhysicalPort) Clone() (PhysicalPort, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPhysicalPort(), err
	}

	return NewPhysicalPortWithBuf(newBuf.Bytes()), nil
}

type PhysicalPortConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPhysicalPortConn(c net.Conn) PhysicalPortConn {
	return PhysicalPortConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PhysicalPortConn) Write(pkts []PhysicalPort) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *PhysicalPortConn) Read(pkts []PhysicalPort) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPhysicalPortWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *PhysicalPort) Init() {
	// Invariants.
}

func (this PhysicalPort) Size() int {
	return 48
}

func ToPhysicalPort(p packet.Packet) (PhysicalPort, error) {
	if !IsPhysicalPort(p) {
		return NewPhysicalPortWithBuf(nil), errors.New("Cannot convert to of10.PhysicalPort")
	}

	return NewPhysicalPortWithBuf(p.Buf), nil
}

func IsPhysicalPort(p packet.Packet) bool {
	return true
}

func (this *PhysicalPort) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PhysicalPort) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *PhysicalPort) PortNoOffset() int {
	offset := 0
	return offset
}

func (this *PhysicalPort) HwAddr() [6]uint8 {
	offset := this.HwAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PhysicalPort) SetHwAddr(h [6]uint8) {
	offset := this.HwAddrOffset()
	for _, e := range h {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PhysicalPort) HwAddrOffset() int {
	offset := 2
	return offset
}

func (this *PhysicalPort) Name() [16]byte {
	offset := this.NameOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 16
	i := 0
	var res [16]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PhysicalPort) SetName(n [16]byte) {
	offset := this.NameOffset()
	for _, e := range n {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PhysicalPort) NameOffset() int {
	offset := 8
	return offset
}

func (this *PhysicalPort) Config() uint32 {
	offset := this.ConfigOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PhysicalPort) SetConfig(c uint32) {
	offset := this.ConfigOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this *PhysicalPort) ConfigOffset() int {
	offset := 24
	return offset
}

func (this *PhysicalPort) State() uint32 {
	offset := this.StateOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PhysicalPort) SetState(s uint32) {
	offset := this.StateOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], s)
	offset += 4
}

func (this *PhysicalPort) StateOffset() int {
	offset := 28
	return offset
}

func (this *PhysicalPort) Curr() uint32 {
	offset := this.CurrOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PhysicalPort) SetCurr(c uint32) {
	offset := this.CurrOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this *PhysicalPort) CurrOffset() int {
	offset := 32
	return offset
}

func (this *PhysicalPort) Advertised() uint32 {
	offset := this.AdvertisedOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PhysicalPort) SetAdvertised(a uint32) {
	offset := this.AdvertisedOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this *PhysicalPort) AdvertisedOffset() int {
	offset := 36
	return offset
}

func (this *PhysicalPort) Supported() uint32 {
	offset := this.SupportedOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PhysicalPort) SetSupported(s uint32) {
	offset := this.SupportedOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], s)
	offset += 4
}

func (this *PhysicalPort) SupportedOffset() int {
	offset := 40
	return offset
}

func (this *PhysicalPort) Peer() uint32 {
	offset := this.PeerOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PhysicalPort) SetPeer(p uint32) {
	offset := this.PeerOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], p)
	offset += 4
}

func (this *PhysicalPort) PeerOffset() int {
	offset := 44
	return offset
}

func NewFeaturesReplyWithBuf(b []byte) FeaturesReply {
	return FeaturesReply{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewFeaturesReply() FeaturesReply {
	s := 32
	b := make([]byte, s)
	p := FeaturesReply{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FeaturesReply struct {
	Header10
}

func (this FeaturesReply) minSize() int {
	return 32
}

func (this FeaturesReply) Clone() (FeaturesReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFeaturesReply(), err
	}

	return NewFeaturesReplyWithBuf(newBuf.Bytes()), nil
}

type FeaturesReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFeaturesReplyConn(c net.Conn) FeaturesReplyConn {
	return FeaturesReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FeaturesReplyConn) Write(pkts []FeaturesReply) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *FeaturesReplyConn) Read(pkts []FeaturesReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFeaturesReplyWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *FeaturesReply) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(6))    // type
	this.SetVersion(uint8(1)) // version
}

func (this FeaturesReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFeaturesReply(p Header10) (FeaturesReply, error) {
	if !IsFeaturesReply(p) {
		return NewFeaturesReplyWithBuf(nil), errors.New("Cannot convert to of10.FeaturesReply")
	}

	return NewFeaturesReplyWithBuf(p.Buf), nil
}

func IsFeaturesReply(p Header10) bool {
	return p.Type() == 6 && true
}

func (this *FeaturesReply) DatapathId() uint64 {
	offset := this.DatapathIdOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetDatapathId(d uint64) {
	offset := this.DatapathIdOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], d)
	offset += 8
}

func (this *FeaturesReply) DatapathIdOffset() int {
	offset := 8
	return offset
}

func (this *FeaturesReply) NBuffers() uint32 {
	offset := this.NBuffersOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetNBuffers(n uint32) {
	offset := this.NBuffersOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], n)
	offset += 4
}

func (this *FeaturesReply) NBuffersOffset() int {
	offset := 16
	return offset
}

func (this *FeaturesReply) NTables() uint8 {
	offset := this.NTablesOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FeaturesReply) SetNTables(n uint8) {
	offset := this.NTablesOffset()
	this.Buf[offset] = byte(n)
	offset++
}

func (this *FeaturesReply) NTablesOffset() int {
	offset := 20
	return offset
}

func (this *FeaturesReply) Pad() [3]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 3
	i := 0
	var res [3]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FeaturesReply) SetPad(p [3]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *FeaturesReply) PadOffset() int {
	offset := 21
	return offset
}

func (this *FeaturesReply) Capabilities() uint32 {
	offset := this.CapabilitiesOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetCapabilities(c uint32) {
	offset := this.CapabilitiesOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this *FeaturesReply) CapabilitiesOffset() int {
	offset := 24
	return offset
}

func (this *FeaturesReply) Actions() uint32 {
	offset := this.ActionsOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FeaturesReply) SetActions(a uint32) {
	offset := this.ActionsOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this *FeaturesReply) ActionsOffset() int {
	offset := 28
	return offset
}

func (this *FeaturesReply) Ports() []PhysicalPort {
	offset := this.PortsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []PhysicalPort
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewPhysicalPortWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FeaturesReply) AddPorts(p PhysicalPort) {
	offset := this.PortsOffset()
	offset += this.PortsSize()
	size := p.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], p.Buf[:p.Size()])
	offset += p.Size()
}

func (this *FeaturesReply) PortsOffset() int {
	offset := 32
	return offset
}

func (this *FeaturesReply) PortsSize() int {
	offset := this.PortsOffset()
	return this.Size() - offset
}

func NewPortStatusWithBuf(b []byte) PortStatus {
	return PortStatus{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewPortStatus() PortStatus {
	s := 64
	b := make([]byte, s)
	p := PortStatus{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PortStatus struct {
	Header10
}

func (this PortStatus) minSize() int {
	return 64
}

func (this PortStatus) Clone() (PortStatus, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortStatus(), err
	}

	return NewPortStatusWithBuf(newBuf.Bytes()), nil
}

type PortStatusConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPortStatusConn(c net.Conn) PortStatusConn {
	return PortStatusConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortStatusConn) Write(pkts []PortStatus) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *PortStatusConn) Read(pkts []PortStatus) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortStatusWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *PortStatus) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(12))   // type
	this.SetVersion(uint8(1)) // version
}

func (this PortStatus) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortStatus(p Header10) (PortStatus, error) {
	if !IsPortStatus(p) {
		return NewPortStatusWithBuf(nil), errors.New("Cannot convert to of10.PortStatus")
	}

	return NewPortStatusWithBuf(p.Buf), nil
}

func IsPortStatus(p Header10) bool {
	return p.Type() == 12 && true
}

func (this *PortStatus) Reason() uint8 {
	offset := this.ReasonOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *PortStatus) SetReason(r uint8) {
	offset := this.ReasonOffset()
	this.Buf[offset] = byte(r)
	offset++
}

func (this *PortStatus) ReasonOffset() int {
	offset := 8
	return offset
}

func (this *PortStatus) Pad() [7]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 7
	i := 0
	var res [7]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortStatus) SetPad(p [7]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PortStatus) PadOffset() int {
	offset := 9
	return offset
}

func (this *PortStatus) Desc() PhysicalPort {
	offset := this.DescOffset()
	res := NewPhysicalPortWithBuf(this.Buf[offset:])
	return res
}

func (this *PortStatus) SetDesc(d PhysicalPort) {
	offset := this.DescOffset()
	copy(this.Buf[offset:], d.Buf[:d.Size()])
	offset += d.Size()
}

func (this *PortStatus) DescOffset() int {
	offset := 16
	return offset
}

func NewPortModWithBuf(b []byte) PortMod {
	return PortMod{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewPortMod() PortMod {
	s := 32
	b := make([]byte, s)
	p := PortMod{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PortMod struct {
	Header10
}

func (this PortMod) minSize() int {
	return 32
}

func (this PortMod) Clone() (PortMod, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortMod(), err
	}

	return NewPortModWithBuf(newBuf.Bytes()), nil
}

type PortModConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPortModConn(c net.Conn) PortModConn {
	return PortModConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortModConn) Write(pkts []PortMod) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *PortModConn) Read(pkts []PortMod) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortModWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *PortMod) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(15))   // type
	this.SetVersion(uint8(1)) // version
}

func (this PortMod) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortMod(p Header10) (PortMod, error) {
	if !IsPortMod(p) {
		return NewPortModWithBuf(nil), errors.New("Cannot convert to of10.PortMod")
	}

	return NewPortModWithBuf(p.Buf), nil
}

func IsPortMod(p Header10) bool {
	return p.Type() == 15 && true
}

func (this *PortMod) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PortMod) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *PortMod) PortNoOffset() int {
	offset := 8
	return offset
}

func (this *PortMod) HwAddr() [6]uint8 {
	offset := this.HwAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortMod) SetHwAddr(h [6]uint8) {
	offset := this.HwAddrOffset()
	for _, e := range h {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PortMod) HwAddrOffset() int {
	offset := 10
	return offset
}

func (this *PortMod) Config() uint32 {
	offset := this.ConfigOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PortMod) SetConfig(c uint32) {
	offset := this.ConfigOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], c)
	offset += 4
}

func (this *PortMod) ConfigOffset() int {
	offset := 16
	return offset
}

func (this *PortMod) Mask() uint32 {
	offset := this.MaskOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PortMod) SetMask(m uint32) {
	offset := this.MaskOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], m)
	offset += 4
}

func (this *PortMod) MaskOffset() int {
	offset := 20
	return offset
}

func (this *PortMod) Advertise() uint32 {
	offset := this.AdvertiseOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PortMod) SetAdvertise(a uint32) {
	offset := this.AdvertiseOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this *PortMod) AdvertiseOffset() int {
	offset := 24
	return offset
}

func (this *PortMod) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortMod) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PortMod) PadOffset() int {
	offset := 28
	return offset
}

func NewPacketInWithBuf(b []byte) PacketIn {
	return PacketIn{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewPacketIn() PacketIn {
	s := 18
	b := make([]byte, s)
	p := PacketIn{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PacketIn struct {
	Header10
}

func (this PacketIn) minSize() int {
	return 18
}

func (this PacketIn) Clone() (PacketIn, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPacketIn(), err
	}

	return NewPacketInWithBuf(newBuf.Bytes()), nil
}

type PacketInConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPacketInConn(c net.Conn) PacketInConn {
	return PacketInConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PacketInConn) Write(pkts []PacketIn) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *PacketInConn) Read(pkts []PacketIn) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPacketInWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *PacketIn) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(10))   // type
	this.SetVersion(uint8(1)) // version
}

func (this PacketIn) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPacketIn(p Header10) (PacketIn, error) {
	if !IsPacketIn(p) {
		return NewPacketInWithBuf(nil), errors.New("Cannot convert to of10.PacketIn")
	}

	return NewPacketInWithBuf(p.Buf), nil
}

func IsPacketIn(p Header10) bool {
	return p.Type() == 10 && true
}

func (this *PacketIn) BufferId() uint32 {
	offset := this.BufferIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PacketIn) SetBufferId(b uint32) {
	offset := this.BufferIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], b)
	offset += 4
}

func (this *PacketIn) BufferIdOffset() int {
	offset := 8
	return offset
}

func (this *PacketIn) TotalLen() uint16 {
	offset := this.TotalLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketIn) SetTotalLen(t uint16) {
	offset := this.TotalLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this *PacketIn) TotalLenOffset() int {
	offset := 12
	return offset
}

func (this *PacketIn) InPort() uint16 {
	offset := this.InPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketIn) SetInPort(i uint16) {
	offset := this.InPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this *PacketIn) InPortOffset() int {
	offset := 14
	return offset
}

func (this *PacketIn) Reason() uint8 {
	offset := this.ReasonOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *PacketIn) SetReason(r uint8) {
	offset := this.ReasonOffset()
	this.Buf[offset] = byte(r)
	offset++
}

func (this *PacketIn) ReasonOffset() int {
	offset := 16
	return offset
}

func (this *PacketIn) Pad() uint8 {
	offset := this.PadOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *PacketIn) SetPad(p uint8) {
	offset := this.PadOffset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this *PacketIn) PadOffset() int {
	offset := 17
	return offset
}

func (this *PacketIn) Data() []uint8 {
	offset := this.DataOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res = append(res, elem)
	}
	return res
}

func (this *PacketIn) AddData(d uint8) {
	offset := this.DataOffset()
	offset += 1
	size := 1
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	this.Buf[offset] = byte(d)
	offset++
}

func (this *PacketIn) DataOffset() int {
	offset := 18
	return offset
}

func (this *PacketIn) DataSize() int {
	offset := this.DataOffset()
	return this.Size() - offset
}

func NewActionHeaderWithBuf(b []byte) ActionHeader {
	return ActionHeader{packet.Packet{Buf: b}}
}

func NewActionHeader() ActionHeader {
	s := 4
	b := make([]byte, s)
	p := ActionHeader{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type ActionHeader struct {
	packet.Packet
}

func (this ActionHeader) minSize() int {
	return 4
}

func (this ActionHeader) Clone() (ActionHeader, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionHeader(), err
	}

	return NewActionHeaderWithBuf(newBuf.Bytes()), nil
}

type ActionHeaderConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionHeaderConn(c net.Conn) ActionHeaderConn {
	return ActionHeaderConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionHeaderConn) Write(pkts []ActionHeader) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionHeaderConn) Read(pkts []ActionHeader) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionHeaderWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionHeader) Init() {
	this.SetLen(uint16(this.minSize()))
	// Invariants.
}

func (this ActionHeader) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionHeader(p packet.Packet) (ActionHeader, error) {
	if !IsActionHeader(p) {
		return NewActionHeaderWithBuf(nil), errors.New("Cannot convert to of10.ActionHeader")
	}

	return NewActionHeaderWithBuf(p.Buf), nil
}

func IsActionHeader(p packet.Packet) bool {
	return true
}

func (this *ActionHeader) Type() uint16 {
	offset := this.TypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ActionHeader) SetType(t uint16) {
	offset := this.TypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this *ActionHeader) TypeOffset() int {
	offset := 0
	return offset
}

func (this *ActionHeader) Len() uint16 {
	offset := this.LenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ActionHeader) SetLen(l uint16) {
	offset := this.LenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this *ActionHeader) LenOffset() int {
	offset := 2
	return offset
}

func NewActionOutputWithBuf(b []byte) ActionOutput {
	return ActionOutput{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionOutput() ActionOutput {
	s := 8
	b := make([]byte, s)
	p := ActionOutput{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionOutput struct {
	ActionHeader
}

func (this ActionOutput) minSize() int {
	return 8
}

func (this ActionOutput) Clone() (ActionOutput, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionOutput(), err
	}

	return NewActionOutputWithBuf(newBuf.Bytes()), nil
}

type ActionOutputConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionOutputConn(c net.Conn) ActionOutputConn {
	return ActionOutputConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionOutputConn) Write(pkts []ActionOutput) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionOutputConn) Read(pkts []ActionOutput) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionOutputWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionOutput) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(0)) // type
}

func (this ActionOutput) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionOutput(p ActionHeader) (ActionOutput, error) {
	if !IsActionOutput(p) {
		return NewActionOutputWithBuf(nil), errors.New("Cannot convert to of10.ActionOutput")
	}

	return NewActionOutputWithBuf(p.Buf), nil
}

func IsActionOutput(p ActionHeader) bool {
	return p.Type() == 0 && true
}

func (this *ActionOutput) Port() uint16 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ActionOutput) SetPort(p uint16) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *ActionOutput) PortOffset() int {
	offset := 4
	return offset
}

func (this *ActionOutput) MaxLen() uint16 {
	offset := this.MaxLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ActionOutput) SetMaxLen(m uint16) {
	offset := this.MaxLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], m)
	offset += 2
}

func (this *ActionOutput) MaxLenOffset() int {
	offset := 6
	return offset
}

func NewActionVlanVidWithBuf(b []byte) ActionVlanVid {
	return ActionVlanVid{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionVlanVid() ActionVlanVid {
	s := 8
	b := make([]byte, s)
	p := ActionVlanVid{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionVlanVid struct {
	ActionHeader
}

func (this ActionVlanVid) minSize() int {
	return 8
}

func (this ActionVlanVid) Clone() (ActionVlanVid, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionVlanVid(), err
	}

	return NewActionVlanVidWithBuf(newBuf.Bytes()), nil
}

type ActionVlanVidConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionVlanVidConn(c net.Conn) ActionVlanVidConn {
	return ActionVlanVidConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionVlanVidConn) Write(pkts []ActionVlanVid) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionVlanVidConn) Read(pkts []ActionVlanVid) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionVlanVidWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionVlanVid) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(1)) // type
}

func (this ActionVlanVid) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionVlanVid(p ActionHeader) (ActionVlanVid, error) {
	if !IsActionVlanVid(p) {
		return NewActionVlanVidWithBuf(nil), errors.New("Cannot convert to of10.ActionVlanVid")
	}

	return NewActionVlanVidWithBuf(p.Buf), nil
}

func IsActionVlanVid(p ActionHeader) bool {
	return p.Type() == 1 && true
}

func (this *ActionVlanVid) VlanVid() uint16 {
	offset := this.VlanVidOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ActionVlanVid) SetVlanVid(v uint16) {
	offset := this.VlanVidOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], v)
	offset += 2
}

func (this *ActionVlanVid) VlanVidOffset() int {
	offset := 4
	return offset
}

func (this *ActionVlanVid) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionVlanVid) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ActionVlanVid) PadOffset() int {
	offset := 6
	return offset
}

func NewActionVlanPcpWithBuf(b []byte) ActionVlanPcp {
	return ActionVlanPcp{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionVlanPcp() ActionVlanPcp {
	s := 8
	b := make([]byte, s)
	p := ActionVlanPcp{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionVlanPcp struct {
	ActionHeader
}

func (this ActionVlanPcp) minSize() int {
	return 8
}

func (this ActionVlanPcp) Clone() (ActionVlanPcp, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionVlanPcp(), err
	}

	return NewActionVlanPcpWithBuf(newBuf.Bytes()), nil
}

type ActionVlanPcpConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionVlanPcpConn(c net.Conn) ActionVlanPcpConn {
	return ActionVlanPcpConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionVlanPcpConn) Write(pkts []ActionVlanPcp) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionVlanPcpConn) Read(pkts []ActionVlanPcp) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionVlanPcpWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionVlanPcp) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(2)) // type
}

func (this ActionVlanPcp) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionVlanPcp(p ActionHeader) (ActionVlanPcp, error) {
	if !IsActionVlanPcp(p) {
		return NewActionVlanPcpWithBuf(nil), errors.New("Cannot convert to of10.ActionVlanPcp")
	}

	return NewActionVlanPcpWithBuf(p.Buf), nil
}

func IsActionVlanPcp(p ActionHeader) bool {
	return p.Type() == 2 && true
}

func (this *ActionVlanPcp) VlanPcp() uint8 {
	offset := this.VlanPcpOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *ActionVlanPcp) SetVlanPcp(v uint8) {
	offset := this.VlanPcpOffset()
	this.Buf[offset] = byte(v)
	offset++
}

func (this *ActionVlanPcp) VlanPcpOffset() int {
	offset := 4
	return offset
}

func (this *ActionVlanPcp) Pad() [3]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 3
	i := 0
	var res [3]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionVlanPcp) SetPad(p [3]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ActionVlanPcp) PadOffset() int {
	offset := 5
	return offset
}

func NewActionDlSrcAddrWithBuf(b []byte) ActionDlSrcAddr {
	return ActionDlSrcAddr{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionDlSrcAddr() ActionDlSrcAddr {
	s := 16
	b := make([]byte, s)
	p := ActionDlSrcAddr{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionDlSrcAddr struct {
	ActionHeader
}

func (this ActionDlSrcAddr) minSize() int {
	return 16
}

func (this ActionDlSrcAddr) Clone() (ActionDlSrcAddr, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionDlSrcAddr(), err
	}

	return NewActionDlSrcAddrWithBuf(newBuf.Bytes()), nil
}

type ActionDlSrcAddrConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionDlSrcAddrConn(c net.Conn) ActionDlSrcAddrConn {
	return ActionDlSrcAddrConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionDlSrcAddrConn) Write(pkts []ActionDlSrcAddr) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionDlSrcAddrConn) Read(pkts []ActionDlSrcAddr) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionDlSrcAddrWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionDlSrcAddr) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(4)) // type
}

func (this ActionDlSrcAddr) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionDlSrcAddr(p ActionHeader) (ActionDlSrcAddr, error) {
	if !IsActionDlSrcAddr(p) {
		return NewActionDlSrcAddrWithBuf(nil), errors.New("Cannot convert to of10.ActionDlSrcAddr")
	}

	return NewActionDlSrcAddrWithBuf(p.Buf), nil
}

func IsActionDlSrcAddr(p ActionHeader) bool {
	return p.Type() == 4 && true
}

func (this *ActionDlSrcAddr) DlAddr() [6]uint8 {
	offset := this.DlAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionDlSrcAddr) SetDlAddr(d [6]uint8) {
	offset := this.DlAddrOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ActionDlSrcAddr) DlAddrOffset() int {
	offset := 4
	return offset
}

func (this *ActionDlSrcAddr) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionDlSrcAddr) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ActionDlSrcAddr) PadOffset() int {
	offset := 10
	return offset
}

func NewActionDlDstAddrWithBuf(b []byte) ActionDlDstAddr {
	return ActionDlDstAddr{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionDlDstAddr() ActionDlDstAddr {
	s := 16
	b := make([]byte, s)
	p := ActionDlDstAddr{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionDlDstAddr struct {
	ActionHeader
}

func (this ActionDlDstAddr) minSize() int {
	return 16
}

func (this ActionDlDstAddr) Clone() (ActionDlDstAddr, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionDlDstAddr(), err
	}

	return NewActionDlDstAddrWithBuf(newBuf.Bytes()), nil
}

type ActionDlDstAddrConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionDlDstAddrConn(c net.Conn) ActionDlDstAddrConn {
	return ActionDlDstAddrConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionDlDstAddrConn) Write(pkts []ActionDlDstAddr) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionDlDstAddrConn) Read(pkts []ActionDlDstAddr) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionDlDstAddrWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionDlDstAddr) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(5)) // type
}

func (this ActionDlDstAddr) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionDlDstAddr(p ActionHeader) (ActionDlDstAddr, error) {
	if !IsActionDlDstAddr(p) {
		return NewActionDlDstAddrWithBuf(nil), errors.New("Cannot convert to of10.ActionDlDstAddr")
	}

	return NewActionDlDstAddrWithBuf(p.Buf), nil
}

func IsActionDlDstAddr(p ActionHeader) bool {
	return p.Type() == 5 && true
}

func (this *ActionDlDstAddr) DlAddr() [6]uint8 {
	offset := this.DlAddrOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionDlDstAddr) SetDlAddr(d [6]uint8) {
	offset := this.DlAddrOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ActionDlDstAddr) DlAddrOffset() int {
	offset := 4
	return offset
}

func (this *ActionDlDstAddr) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionDlDstAddr) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ActionDlDstAddr) PadOffset() int {
	offset := 10
	return offset
}

func NewActionNwSrcAddrWithBuf(b []byte) ActionNwSrcAddr {
	return ActionNwSrcAddr{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionNwSrcAddr() ActionNwSrcAddr {
	s := 8
	b := make([]byte, s)
	p := ActionNwSrcAddr{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionNwSrcAddr struct {
	ActionHeader
}

func (this ActionNwSrcAddr) minSize() int {
	return 8
}

func (this ActionNwSrcAddr) Clone() (ActionNwSrcAddr, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionNwSrcAddr(), err
	}

	return NewActionNwSrcAddrWithBuf(newBuf.Bytes()), nil
}

type ActionNwSrcAddrConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionNwSrcAddrConn(c net.Conn) ActionNwSrcAddrConn {
	return ActionNwSrcAddrConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionNwSrcAddrConn) Write(pkts []ActionNwSrcAddr) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionNwSrcAddrConn) Read(pkts []ActionNwSrcAddr) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionNwSrcAddrWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionNwSrcAddr) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(6)) // type
}

func (this ActionNwSrcAddr) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionNwSrcAddr(p ActionHeader) (ActionNwSrcAddr, error) {
	if !IsActionNwSrcAddr(p) {
		return NewActionNwSrcAddrWithBuf(nil), errors.New("Cannot convert to of10.ActionNwSrcAddr")
	}

	return NewActionNwSrcAddrWithBuf(p.Buf), nil
}

func IsActionNwSrcAddr(p ActionHeader) bool {
	return p.Type() == 6 && true
}

func (this *ActionNwSrcAddr) NwAddr() uint32 {
	offset := this.NwAddrOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *ActionNwSrcAddr) SetNwAddr(n uint32) {
	offset := this.NwAddrOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], n)
	offset += 4
}

func (this *ActionNwSrcAddr) NwAddrOffset() int {
	offset := 4
	return offset
}

func NewActionNwDstAddrWithBuf(b []byte) ActionNwDstAddr {
	return ActionNwDstAddr{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionNwDstAddr() ActionNwDstAddr {
	s := 8
	b := make([]byte, s)
	p := ActionNwDstAddr{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionNwDstAddr struct {
	ActionHeader
}

func (this ActionNwDstAddr) minSize() int {
	return 8
}

func (this ActionNwDstAddr) Clone() (ActionNwDstAddr, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionNwDstAddr(), err
	}

	return NewActionNwDstAddrWithBuf(newBuf.Bytes()), nil
}

type ActionNwDstAddrConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionNwDstAddrConn(c net.Conn) ActionNwDstAddrConn {
	return ActionNwDstAddrConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionNwDstAddrConn) Write(pkts []ActionNwDstAddr) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionNwDstAddrConn) Read(pkts []ActionNwDstAddr) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionNwDstAddrWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionNwDstAddr) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(7)) // type
}

func (this ActionNwDstAddr) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionNwDstAddr(p ActionHeader) (ActionNwDstAddr, error) {
	if !IsActionNwDstAddr(p) {
		return NewActionNwDstAddrWithBuf(nil), errors.New("Cannot convert to of10.ActionNwDstAddr")
	}

	return NewActionNwDstAddrWithBuf(p.Buf), nil
}

func IsActionNwDstAddr(p ActionHeader) bool {
	return p.Type() == 7 && true
}

func (this *ActionNwDstAddr) NwAddr() uint32 {
	offset := this.NwAddrOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *ActionNwDstAddr) SetNwAddr(n uint32) {
	offset := this.NwAddrOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], n)
	offset += 4
}

func (this *ActionNwDstAddr) NwAddrOffset() int {
	offset := 4
	return offset
}

func NewActionTpSrcPortWithBuf(b []byte) ActionTpSrcPort {
	return ActionTpSrcPort{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionTpSrcPort() ActionTpSrcPort {
	s := 8
	b := make([]byte, s)
	p := ActionTpSrcPort{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionTpSrcPort struct {
	ActionHeader
}

func (this ActionTpSrcPort) minSize() int {
	return 8
}

func (this ActionTpSrcPort) Clone() (ActionTpSrcPort, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionTpSrcPort(), err
	}

	return NewActionTpSrcPortWithBuf(newBuf.Bytes()), nil
}

type ActionTpSrcPortConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionTpSrcPortConn(c net.Conn) ActionTpSrcPortConn {
	return ActionTpSrcPortConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionTpSrcPortConn) Write(pkts []ActionTpSrcPort) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionTpSrcPortConn) Read(pkts []ActionTpSrcPort) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionTpSrcPortWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionTpSrcPort) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(9)) // type
}

func (this ActionTpSrcPort) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionTpSrcPort(p ActionHeader) (ActionTpSrcPort, error) {
	if !IsActionTpSrcPort(p) {
		return NewActionTpSrcPortWithBuf(nil), errors.New("Cannot convert to of10.ActionTpSrcPort")
	}

	return NewActionTpSrcPortWithBuf(p.Buf), nil
}

func IsActionTpSrcPort(p ActionHeader) bool {
	return p.Type() == 9 && true
}

func (this *ActionTpSrcPort) TpPort() uint16 {
	offset := this.TpPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ActionTpSrcPort) SetTpPort(t uint16) {
	offset := this.TpPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this *ActionTpSrcPort) TpPortOffset() int {
	offset := 4
	return offset
}

func (this *ActionTpSrcPort) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionTpSrcPort) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ActionTpSrcPort) PadOffset() int {
	offset := 6
	return offset
}

func NewActionTpDstPortWithBuf(b []byte) ActionTpDstPort {
	return ActionTpDstPort{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionTpDstPort() ActionTpDstPort {
	s := 8
	b := make([]byte, s)
	p := ActionTpDstPort{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionTpDstPort struct {
	ActionHeader
}

func (this ActionTpDstPort) minSize() int {
	return 8
}

func (this ActionTpDstPort) Clone() (ActionTpDstPort, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionTpDstPort(), err
	}

	return NewActionTpDstPortWithBuf(newBuf.Bytes()), nil
}

type ActionTpDstPortConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionTpDstPortConn(c net.Conn) ActionTpDstPortConn {
	return ActionTpDstPortConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionTpDstPortConn) Write(pkts []ActionTpDstPort) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionTpDstPortConn) Read(pkts []ActionTpDstPort) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionTpDstPortWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionTpDstPort) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(10)) // type
}

func (this ActionTpDstPort) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionTpDstPort(p ActionHeader) (ActionTpDstPort, error) {
	if !IsActionTpDstPort(p) {
		return NewActionTpDstPortWithBuf(nil), errors.New("Cannot convert to of10.ActionTpDstPort")
	}

	return NewActionTpDstPortWithBuf(p.Buf), nil
}

func IsActionTpDstPort(p ActionHeader) bool {
	return p.Type() == 10 && true
}

func (this *ActionTpDstPort) TpPort() uint16 {
	offset := this.TpPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ActionTpDstPort) SetTpPort(t uint16) {
	offset := this.TpPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this *ActionTpDstPort) TpPortOffset() int {
	offset := 4
	return offset
}

func (this *ActionTpDstPort) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionTpDstPort) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ActionTpDstPort) PadOffset() int {
	offset := 6
	return offset
}

func NewActionNwTosWithBuf(b []byte) ActionNwTos {
	return ActionNwTos{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionNwTos() ActionNwTos {
	s := 8
	b := make([]byte, s)
	p := ActionNwTos{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionNwTos struct {
	ActionHeader
}

func (this ActionNwTos) minSize() int {
	return 8
}

func (this ActionNwTos) Clone() (ActionNwTos, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionNwTos(), err
	}

	return NewActionNwTosWithBuf(newBuf.Bytes()), nil
}

type ActionNwTosConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionNwTosConn(c net.Conn) ActionNwTosConn {
	return ActionNwTosConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionNwTosConn) Write(pkts []ActionNwTos) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionNwTosConn) Read(pkts []ActionNwTos) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionNwTosWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionNwTos) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(8)) // type
}

func (this ActionNwTos) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionNwTos(p ActionHeader) (ActionNwTos, error) {
	if !IsActionNwTos(p) {
		return NewActionNwTosWithBuf(nil), errors.New("Cannot convert to of10.ActionNwTos")
	}

	return NewActionNwTosWithBuf(p.Buf), nil
}

func IsActionNwTos(p ActionHeader) bool {
	return p.Type() == 8 && true
}

func (this *ActionNwTos) NwTos() uint8 {
	offset := this.NwTosOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *ActionNwTos) SetNwTos(n uint8) {
	offset := this.NwTosOffset()
	this.Buf[offset] = byte(n)
	offset++
}

func (this *ActionNwTos) NwTosOffset() int {
	offset := 4
	return offset
}

func (this *ActionNwTos) Pad() [3]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 3
	i := 0
	var res [3]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionNwTos) SetPad(p [3]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ActionNwTos) PadOffset() int {
	offset := 5
	return offset
}

func NewActionVendorHeaderWithBuf(b []byte) ActionVendorHeader {
	return ActionVendorHeader{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionVendorHeader() ActionVendorHeader {
	s := 8
	b := make([]byte, s)
	p := ActionVendorHeader{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionVendorHeader struct {
	ActionHeader
}

func (this ActionVendorHeader) minSize() int {
	return 8
}

func (this ActionVendorHeader) Clone() (ActionVendorHeader, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionVendorHeader(), err
	}

	return NewActionVendorHeaderWithBuf(newBuf.Bytes()), nil
}

type ActionVendorHeaderConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionVendorHeaderConn(c net.Conn) ActionVendorHeaderConn {
	return ActionVendorHeaderConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionVendorHeaderConn) Write(pkts []ActionVendorHeader) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionVendorHeaderConn) Read(pkts []ActionVendorHeader) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionVendorHeaderWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionVendorHeader) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(65535)) // type
}

func (this ActionVendorHeader) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionVendorHeader(p ActionHeader) (ActionVendorHeader, error) {
	if !IsActionVendorHeader(p) {
		return NewActionVendorHeaderWithBuf(nil), errors.New("Cannot convert to of10.ActionVendorHeader")
	}

	return NewActionVendorHeaderWithBuf(p.Buf), nil
}

func IsActionVendorHeader(p ActionHeader) bool {
	return p.Type() == 65535 && true
}

func (this *ActionVendorHeader) Vendor() uint32 {
	offset := this.VendorOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *ActionVendorHeader) SetVendor(v uint32) {
	offset := this.VendorOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], v)
	offset += 4
}

func (this *ActionVendorHeader) VendorOffset() int {
	offset := 4
	return offset
}

func NewPacketOutWithBuf(b []byte) PacketOut {
	return PacketOut{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewPacketOut() PacketOut {
	s := 16
	b := make([]byte, s)
	p := PacketOut{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type PacketOut struct {
	Header10
}

func (this PacketOut) minSize() int {
	return 16
}

func (this PacketOut) Clone() (PacketOut, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPacketOut(), err
	}

	return NewPacketOutWithBuf(newBuf.Bytes()), nil
}

type PacketOutConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPacketOutConn(c net.Conn) PacketOutConn {
	return PacketOutConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PacketOutConn) Write(pkts []PacketOut) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *PacketOutConn) Read(pkts []PacketOut) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPacketOutWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *PacketOut) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(13))   // type
	this.SetVersion(uint8(1)) // version
}

func (this PacketOut) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPacketOut(p Header10) (PacketOut, error) {
	if !IsPacketOut(p) {
		return NewPacketOutWithBuf(nil), errors.New("Cannot convert to of10.PacketOut")
	}

	return NewPacketOutWithBuf(p.Buf), nil
}

func IsPacketOut(p Header10) bool {
	return p.Type() == 13 && true
}

func (this *PacketOut) BufferId() uint32 {
	offset := this.BufferIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PacketOut) SetBufferId(b uint32) {
	offset := this.BufferIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], b)
	offset += 4
}

func (this *PacketOut) BufferIdOffset() int {
	offset := 8
	return offset
}

func (this *PacketOut) InPort() uint16 {
	offset := this.InPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketOut) SetInPort(i uint16) {
	offset := this.InPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this *PacketOut) InPortOffset() int {
	offset := 12
	return offset
}

func (this *PacketOut) ActionsLen() uint16 {
	offset := this.ActionsLenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketOut) SetActionsLen(a uint16) {
	offset := this.ActionsLenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], a)
	offset += 2
}

func (this *PacketOut) ActionsLenOffset() int {
	offset := 14
	return offset
}

func (this *PacketOut) Actions() []ActionHeader {
	offset := this.ActionsOffset()
	packet_size := this.Size()
	size := int(this.ActionsLen())
	count := this.Size() - offset
	var res []ActionHeader
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewActionHeaderWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *PacketOut) AddActions(a ActionHeader) {
	offset := this.ActionsOffset()
	offset += this.ActionsSize()
	size := a.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], a.Buf[:a.Size()])
	offset += a.Size()
	this.SetActionsLen(this.ActionsLen() + uint16(size))
}

func (this *PacketOut) ActionsOffset() int {
	offset := 16
	return offset
}

func (this *PacketOut) ActionsSize() int {
	return int(this.ActionsLen())
}

func (this *PacketOut) Data() []uint8 {
	offset := this.DataOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res = append(res, elem)
	}
	return res
}

func (this *PacketOut) AddData(d uint8) {
	offset := this.DataOffset()
	offset += 1
	size := 1
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	this.Buf[offset] = byte(d)
	offset++
}

func (this *PacketOut) DataOffset() int {
	offset := 16
	offset += this.ActionsSize()
	return offset
}

func (this *PacketOut) DataSize() int {
	offset := this.DataOffset()
	return this.Size() - offset
}

func NewMatchWithBuf(b []byte) Match {
	return Match{packet.Packet{Buf: b}}
}

func NewMatch() Match {
	s := 40
	b := make([]byte, s)
	p := Match{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type Match struct {
	packet.Packet
}

func (this Match) minSize() int {
	return 40
}

func (this Match) Clone() (Match, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewMatch(), err
	}

	return NewMatchWithBuf(newBuf.Bytes()), nil
}

type MatchConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewMatchConn(c net.Conn) MatchConn {
	return MatchConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *MatchConn) Write(pkts []Match) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *MatchConn) Read(pkts []Match) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewMatchWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *Match) Init() {
	// Invariants.
}

func (this Match) Size() int {
	return 40
}

func ToMatch(p packet.Packet) (Match, error) {
	if !IsMatch(p) {
		return NewMatchWithBuf(nil), errors.New("Cannot convert to of10.Match")
	}

	return NewMatchWithBuf(p.Buf), nil
}

func IsMatch(p packet.Packet) bool {
	return true
}

func (this *Match) Wildcards() uint32 {
	offset := this.WildcardsOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Match) SetWildcards(w uint32) {
	offset := this.WildcardsOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], w)
	offset += 4
}

func (this *Match) WildcardsOffset() int {
	offset := 0
	return offset
}

func (this *Match) InPort() uint16 {
	offset := this.InPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Match) SetInPort(i uint16) {
	offset := this.InPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this *Match) InPortOffset() int {
	offset := 4
	return offset
}

func (this *Match) DlSrc() [6]uint8 {
	offset := this.DlSrcOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Match) SetDlSrc(d [6]uint8) {
	offset := this.DlSrcOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *Match) DlSrcOffset() int {
	offset := 6
	return offset
}

func (this *Match) DlDst() [6]uint8 {
	offset := this.DlDstOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Match) SetDlDst(d [6]uint8) {
	offset := this.DlDstOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *Match) DlDstOffset() int {
	offset := 12
	return offset
}

func (this *Match) DlVlan() uint16 {
	offset := this.DlVlanOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Match) SetDlVlan(d uint16) {
	offset := this.DlVlanOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], d)
	offset += 2
}

func (this *Match) DlVlanOffset() int {
	offset := 18
	return offset
}

func (this *Match) DlVlanPcp() uint8 {
	offset := this.DlVlanPcpOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *Match) SetDlVlanPcp(d uint8) {
	offset := this.DlVlanPcpOffset()
	this.Buf[offset] = byte(d)
	offset++
}

func (this *Match) DlVlanPcpOffset() int {
	offset := 20
	return offset
}

func (this *Match) Pad1() [1]uint8 {
	offset := this.Pad1Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 1
	i := 0
	var res [1]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Match) SetPad1(p [1]uint8) {
	offset := this.Pad1Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *Match) Pad1Offset() int {
	offset := 21
	return offset
}

func (this *Match) DlType() uint16 {
	offset := this.DlTypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Match) SetDlType(d uint16) {
	offset := this.DlTypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], d)
	offset += 2
}

func (this *Match) DlTypeOffset() int {
	offset := 22
	return offset
}

func (this *Match) NwTos() uint8 {
	offset := this.NwTosOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *Match) SetNwTos(n uint8) {
	offset := this.NwTosOffset()
	this.Buf[offset] = byte(n)
	offset++
}

func (this *Match) NwTosOffset() int {
	offset := 24
	return offset
}

func (this *Match) NwProto() uint8 {
	offset := this.NwProtoOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *Match) SetNwProto(n uint8) {
	offset := this.NwProtoOffset()
	this.Buf[offset] = byte(n)
	offset++
}

func (this *Match) NwProtoOffset() int {
	offset := 25
	return offset
}

func (this *Match) Pad2() [2]uint8 {
	offset := this.Pad2Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *Match) SetPad2(p [2]uint8) {
	offset := this.Pad2Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *Match) Pad2Offset() int {
	offset := 26
	return offset
}

func (this *Match) NwSrc() uint32 {
	offset := this.NwSrcOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Match) SetNwSrc(n uint32) {
	offset := this.NwSrcOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], n)
	offset += 4
}

func (this *Match) NwSrcOffset() int {
	offset := 28
	return offset
}

func (this *Match) NwDst() uint32 {
	offset := this.NwDstOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *Match) SetNwDst(n uint32) {
	offset := this.NwDstOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], n)
	offset += 4
}

func (this *Match) NwDstOffset() int {
	offset := 32
	return offset
}

func (this *Match) TpSrc() uint16 {
	offset := this.TpSrcOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Match) SetTpSrc(t uint16) {
	offset := this.TpSrcOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this *Match) TpSrcOffset() int {
	offset := 36
	return offset
}

func (this *Match) TpDst() uint16 {
	offset := this.TpDstOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *Match) SetTpDst(t uint16) {
	offset := this.TpDstOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], t)
	offset += 2
}

func (this *Match) TpDstOffset() int {
	offset := 38
	return offset
}

func NewFlowModWithBuf(b []byte) FlowMod {
	return FlowMod{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewFlowMod() FlowMod {
	s := 72
	b := make([]byte, s)
	p := FlowMod{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FlowMod struct {
	Header10
}

func (this FlowMod) minSize() int {
	return 72
}

func (this FlowMod) Clone() (FlowMod, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowMod(), err
	}

	return NewFlowModWithBuf(newBuf.Bytes()), nil
}

type FlowModConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFlowModConn(c net.Conn) FlowModConn {
	return FlowModConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowModConn) Write(pkts []FlowMod) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *FlowModConn) Read(pkts []FlowMod) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowModWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *FlowMod) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(14))   // type
	this.SetVersion(uint8(1)) // version
}

func (this FlowMod) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowMod(p Header10) (FlowMod, error) {
	if !IsFlowMod(p) {
		return NewFlowModWithBuf(nil), errors.New("Cannot convert to of10.FlowMod")
	}

	return NewFlowModWithBuf(p.Buf), nil
}

func IsFlowMod(p Header10) bool {
	return p.Type() == 14 && true
}

func (this *FlowMod) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetMatch(m Match) {
	offset := this.MatchOffset()
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this *FlowMod) MatchOffset() int {
	offset := 8
	return offset
}

func (this *FlowMod) Cookie() uint64 {
	offset := this.CookieOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetCookie(c uint64) {
	offset := this.CookieOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this *FlowMod) CookieOffset() int {
	offset := 48
	return offset
}

func (this *FlowMod) Command() uint16 {
	offset := this.CommandOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetCommand(c uint16) {
	offset := this.CommandOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], c)
	offset += 2
}

func (this *FlowMod) CommandOffset() int {
	offset := 56
	return offset
}

func (this *FlowMod) IdleTimeout() uint16 {
	offset := this.IdleTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetIdleTimeout(i uint16) {
	offset := this.IdleTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this *FlowMod) IdleTimeoutOffset() int {
	offset := 58
	return offset
}

func (this *FlowMod) HardTimeout() uint16 {
	offset := this.HardTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetHardTimeout(h uint16) {
	offset := this.HardTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], h)
	offset += 2
}

func (this *FlowMod) HardTimeoutOffset() int {
	offset := 60
	return offset
}

func (this *FlowMod) Priority() uint16 {
	offset := this.PriorityOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetPriority(p uint16) {
	offset := this.PriorityOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *FlowMod) PriorityOffset() int {
	offset := 62
	return offset
}

func (this *FlowMod) BufferId() uint32 {
	offset := this.BufferIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetBufferId(b uint32) {
	offset := this.BufferIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], b)
	offset += 4
}

func (this *FlowMod) BufferIdOffset() int {
	offset := 64
	return offset
}

func (this *FlowMod) OutPort() uint16 {
	offset := this.OutPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetOutPort(o uint16) {
	offset := this.OutPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], o)
	offset += 2
}

func (this *FlowMod) OutPortOffset() int {
	offset := 68
	return offset
}

func (this *FlowMod) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowMod) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this *FlowMod) FlagsOffset() int {
	offset := 70
	return offset
}

func (this *FlowMod) Actions() []ActionHeader {
	offset := this.ActionsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []ActionHeader
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewActionHeaderWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FlowMod) AddActions(a ActionHeader) {
	offset := this.ActionsOffset()
	offset += this.ActionsSize()
	size := a.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], a.Buf[:a.Size()])
	offset += a.Size()
}

func (this *FlowMod) ActionsOffset() int {
	offset := 72
	return offset
}

func (this *FlowMod) ActionsSize() int {
	offset := this.ActionsOffset()
	return this.Size() - offset
}

func NewFlowRemovedWithBuf(b []byte) FlowRemoved {
	return FlowRemoved{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewFlowRemoved() FlowRemoved {
	s := 88
	b := make([]byte, s)
	p := FlowRemoved{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type FlowRemoved struct {
	Header10
}

func (this FlowRemoved) minSize() int {
	return 88
}

func (this FlowRemoved) Clone() (FlowRemoved, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowRemoved(), err
	}

	return NewFlowRemovedWithBuf(newBuf.Bytes()), nil
}

type FlowRemovedConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFlowRemovedConn(c net.Conn) FlowRemovedConn {
	return FlowRemovedConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowRemovedConn) Write(pkts []FlowRemoved) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *FlowRemovedConn) Read(pkts []FlowRemoved) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowRemovedWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *FlowRemoved) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(11))   // type
	this.SetVersion(uint8(1)) // version
}

func (this FlowRemoved) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowRemoved(p Header10) (FlowRemoved, error) {
	if !IsFlowRemoved(p) {
		return NewFlowRemovedWithBuf(nil), errors.New("Cannot convert to of10.FlowRemoved")
	}

	return NewFlowRemovedWithBuf(p.Buf), nil
}

func IsFlowRemoved(p Header10) bool {
	return p.Type() == 11 && true
}

func (this *FlowRemoved) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetMatch(m Match) {
	offset := this.MatchOffset()
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this *FlowRemoved) MatchOffset() int {
	offset := 8
	return offset
}

func (this *FlowRemoved) Cookie() uint64 {
	offset := this.CookieOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetCookie(c uint64) {
	offset := this.CookieOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this *FlowRemoved) CookieOffset() int {
	offset := 48
	return offset
}

func (this *FlowRemoved) Priority() uint16 {
	offset := this.PriorityOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetPriority(p uint16) {
	offset := this.PriorityOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *FlowRemoved) PriorityOffset() int {
	offset := 56
	return offset
}

func (this *FlowRemoved) Reason() uint8 {
	offset := this.ReasonOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowRemoved) SetReason(r uint8) {
	offset := this.ReasonOffset()
	this.Buf[offset] = byte(r)
	offset++
}

func (this *FlowRemoved) ReasonOffset() int {
	offset := 58
	return offset
}

func (this *FlowRemoved) Pad() [1]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 1
	i := 0
	var res [1]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowRemoved) SetPad(p [1]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *FlowRemoved) PadOffset() int {
	offset := 59
	return offset
}

func (this *FlowRemoved) DurationSec() uint32 {
	offset := this.DurationSecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetDurationSec(d uint32) {
	offset := this.DurationSecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this *FlowRemoved) DurationSecOffset() int {
	offset := 60
	return offset
}

func (this *FlowRemoved) DurationNsec() uint32 {
	offset := this.DurationNsecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetDurationNsec(d uint32) {
	offset := this.DurationNsecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this *FlowRemoved) DurationNsecOffset() int {
	offset := 64
	return offset
}

func (this *FlowRemoved) IdleTimeout() uint16 {
	offset := this.IdleTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetIdleTimeout(i uint16) {
	offset := this.IdleTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this *FlowRemoved) IdleTimeoutOffset() int {
	offset := 68
	return offset
}

func (this *FlowRemoved) Pad2() [2]uint8 {
	offset := this.Pad2Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowRemoved) SetPad2(p [2]uint8) {
	offset := this.Pad2Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *FlowRemoved) Pad2Offset() int {
	offset := 70
	return offset
}

func (this *FlowRemoved) PacketCount() uint64 {
	offset := this.PacketCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetPacketCount(p uint64) {
	offset := this.PacketCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], p)
	offset += 8
}

func (this *FlowRemoved) PacketCountOffset() int {
	offset := 72
	return offset
}

func (this *FlowRemoved) ByteCount() uint64 {
	offset := this.ByteCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowRemoved) SetByteCount(b uint64) {
	offset := this.ByteCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], b)
	offset += 8
}

func (this *FlowRemoved) ByteCountOffset() int {
	offset := 80
	return offset
}

func NewErrorMsgWithBuf(b []byte) ErrorMsg {
	return ErrorMsg{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewErrorMsg() ErrorMsg {
	s := 12
	b := make([]byte, s)
	p := ErrorMsg{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type ErrorMsg struct {
	Header10
}

func (this ErrorMsg) minSize() int {
	return 12
}

func (this ErrorMsg) Clone() (ErrorMsg, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewErrorMsg(), err
	}

	return NewErrorMsgWithBuf(newBuf.Bytes()), nil
}

type ErrorMsgConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewErrorMsgConn(c net.Conn) ErrorMsgConn {
	return ErrorMsgConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ErrorMsgConn) Write(pkts []ErrorMsg) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ErrorMsgConn) Read(pkts []ErrorMsg) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewErrorMsgWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ErrorMsg) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(1))    // type
	this.SetVersion(uint8(1)) // version
}

func (this ErrorMsg) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToErrorMsg(p Header10) (ErrorMsg, error) {
	if !IsErrorMsg(p) {
		return NewErrorMsgWithBuf(nil), errors.New("Cannot convert to of10.ErrorMsg")
	}

	return NewErrorMsgWithBuf(p.Buf), nil
}

func IsErrorMsg(p Header10) bool {
	return p.Type() == 1 && true
}

func (this *ErrorMsg) ErrType() uint16 {
	offset := this.ErrTypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ErrorMsg) SetErrType(e uint16) {
	offset := this.ErrTypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], e)
	offset += 2
}

func (this *ErrorMsg) ErrTypeOffset() int {
	offset := 8
	return offset
}

func (this *ErrorMsg) Code() uint16 {
	offset := this.CodeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ErrorMsg) SetCode(c uint16) {
	offset := this.CodeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], c)
	offset += 2
}

func (this *ErrorMsg) CodeOffset() int {
	offset := 10
	return offset
}

func (this *ErrorMsg) Data() []uint8 {
	offset := this.DataOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res = append(res, elem)
	}
	return res
}

func (this *ErrorMsg) AddData(d uint8) {
	offset := this.DataOffset()
	offset += 1
	size := 1
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	this.Buf[offset] = byte(d)
	offset++
}

func (this *ErrorMsg) DataOffset() int {
	offset := 12
	return offset
}

func (this *ErrorMsg) DataSize() int {
	offset := this.DataOffset()
	return this.Size() - offset
}

func NewStatsRequestWithBuf(b []byte) StatsRequest {
	return StatsRequest{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewStatsRequest() StatsRequest {
	s := 12
	b := make([]byte, s)
	p := StatsRequest{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type StatsRequest struct {
	Header10
}

func (this StatsRequest) minSize() int {
	return 12
}

func (this StatsRequest) Clone() (StatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewStatsRequest(), err
	}

	return NewStatsRequestWithBuf(newBuf.Bytes()), nil
}

type StatsRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewStatsRequestConn(c net.Conn) StatsRequestConn {
	return StatsRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *StatsRequestConn) Write(pkts []StatsRequest) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *StatsRequestConn) Read(pkts []StatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewStatsRequestWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *StatsRequest) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(16))   // type
	this.SetVersion(uint8(1)) // version
}

func (this StatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToStatsRequest(p Header10) (StatsRequest, error) {
	if !IsStatsRequest(p) {
		return NewStatsRequestWithBuf(nil), errors.New("Cannot convert to of10.StatsRequest")
	}

	return NewStatsRequestWithBuf(p.Buf), nil
}

func IsStatsRequest(p Header10) bool {
	return p.Type() == 16 && true
}

func (this *StatsRequest) StatsType() uint16 {
	offset := this.StatsTypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsRequest) SetStatsType(s uint16) {
	offset := this.StatsTypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], s)
	offset += 2
}

func (this *StatsRequest) StatsTypeOffset() int {
	offset := 8
	return offset
}

func (this *StatsRequest) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsRequest) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this *StatsRequest) FlagsOffset() int {
	offset := 10
	return offset
}

func NewStatsReplyWithBuf(b []byte) StatsReply {
	return StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewStatsReply() StatsReply {
	s := 12
	b := make([]byte, s)
	p := StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type StatsReply struct {
	Header10
}

func (this StatsReply) minSize() int {
	return 12
}

func (this StatsReply) Clone() (StatsReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewStatsReply(), err
	}

	return NewStatsReplyWithBuf(newBuf.Bytes()), nil
}

type StatsReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewStatsReplyConn(c net.Conn) StatsReplyConn {
	return StatsReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *StatsReplyConn) Write(pkts []StatsReply) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *StatsReplyConn) Read(pkts []StatsReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewStatsReplyWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *StatsReply) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(17))   // type
	this.SetVersion(uint8(1)) // version
}

func (this StatsReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToStatsReply(p Header10) (StatsReply, error) {
	if !IsStatsReply(p) {
		return NewStatsReplyWithBuf(nil), errors.New("Cannot convert to of10.StatsReply")
	}

	return NewStatsReplyWithBuf(p.Buf), nil
}

func IsStatsReply(p Header10) bool {
	return p.Type() == 17 && true
}

func (this *StatsReply) StatsType() uint16 {
	offset := this.StatsTypeOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsReply) SetStatsType(s uint16) {
	offset := this.StatsTypeOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], s)
	offset += 2
}

func (this *StatsReply) StatsTypeOffset() int {
	offset := 8
	return offset
}

func (this *StatsReply) Flags() uint16 {
	offset := this.FlagsOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *StatsReply) SetFlags(f uint16) {
	offset := this.FlagsOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], f)
	offset += 2
}

func (this *StatsReply) FlagsOffset() int {
	offset := 10
	return offset
}

func NewDescStatsWithBuf(b []byte) DescStats {
	return DescStats{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
}

func NewDescStats() DescStats {
	s := 1068
	b := make([]byte, s)
	p := DescStats{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type DescStats struct {
	StatsReply
}

func (this DescStats) minSize() int {
	return 1068
}

func (this DescStats) Clone() (DescStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewDescStats(), err
	}

	return NewDescStatsWithBuf(newBuf.Bytes()), nil
}

type DescStatsConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewDescStatsConn(c net.Conn) DescStatsConn {
	return DescStatsConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *DescStatsConn) Write(pkts []DescStats) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *DescStatsConn) Read(pkts []DescStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewDescStatsWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *DescStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(0)) // stats_type
	this.SetType(uint8(17))      // type
	this.SetVersion(uint8(1))    // version
}

func (this DescStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToDescStats(p StatsReply) (DescStats, error) {
	if !IsDescStats(p) {
		return NewDescStatsWithBuf(nil), errors.New("Cannot convert to of10.DescStats")
	}

	return NewDescStatsWithBuf(p.Buf), nil
}

func IsDescStats(p StatsReply) bool {
	return p.StatsType() == 0 && true
}

func (this *DescStats) MfrDesc() [256]byte {
	offset := this.MfrDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetMfrDesc(m [256]byte) {
	offset := this.MfrDescOffset()
	for _, e := range m {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *DescStats) MfrDescOffset() int {
	offset := 12
	return offset
}

func (this *DescStats) HwDesc() [256]byte {
	offset := this.HwDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetHwDesc(h [256]byte) {
	offset := this.HwDescOffset()
	for _, e := range h {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *DescStats) HwDescOffset() int {
	offset := 268
	return offset
}

func (this *DescStats) SwDesc() [256]byte {
	offset := this.SwDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetSwDesc(s [256]byte) {
	offset := this.SwDescOffset()
	for _, e := range s {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *DescStats) SwDescOffset() int {
	offset := 524
	return offset
}

func (this *DescStats) SerialNum() [32]byte {
	offset := this.SerialNumOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 32
	i := 0
	var res [32]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetSerialNum(s [32]byte) {
	offset := this.SerialNumOffset()
	for _, e := range s {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *DescStats) SerialNumOffset() int {
	offset := 780
	return offset
}

func (this *DescStats) DpDesc() [256]byte {
	offset := this.DpDescOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 256
	i := 0
	var res [256]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *DescStats) SetDpDesc(d [256]byte) {
	offset := this.DpDescOffset()
	for _, e := range d {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *DescStats) DpDescOffset() int {
	offset := 812
	return offset
}

func NewFlowStatsRequestWithBuf(b []byte) FlowStatsRequest {
	return FlowStatsRequest{StatsRequest{Header10{of.Header{packet.Packet{Buf: b}}}}}
}

func NewFlowStatsRequest() FlowStatsRequest {
	s := 56
	b := make([]byte, s)
	p := FlowStatsRequest{StatsRequest{Header10{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type FlowStatsRequest struct {
	StatsRequest
}

func (this FlowStatsRequest) minSize() int {
	return 56
}

func (this FlowStatsRequest) Clone() (FlowStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowStatsRequest(), err
	}

	return NewFlowStatsRequestWithBuf(newBuf.Bytes()), nil
}

type FlowStatsRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFlowStatsRequestConn(c net.Conn) FlowStatsRequestConn {
	return FlowStatsRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowStatsRequestConn) Write(pkts []FlowStatsRequest) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *FlowStatsRequestConn) Read(pkts []FlowStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowStatsRequestWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *FlowStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(1)) // stats_type
	this.SetType(uint8(16))      // type
	this.SetVersion(uint8(1))    // version
}

func (this FlowStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowStatsRequest(p StatsRequest) (FlowStatsRequest, error) {
	if !IsFlowStatsRequest(p) {
		return NewFlowStatsRequestWithBuf(nil), errors.New("Cannot convert to of10.FlowStatsRequest")
	}

	return NewFlowStatsRequestWithBuf(p.Buf), nil
}

func IsFlowStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 1 && true
}

func (this *FlowStatsRequest) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowStatsRequest) SetMatch(m Match) {
	offset := this.MatchOffset()
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this *FlowStatsRequest) MatchOffset() int {
	offset := 12
	return offset
}

func (this *FlowStatsRequest) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowStatsRequest) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this *FlowStatsRequest) TableIdOffset() int {
	offset := 52
	return offset
}

func (this *FlowStatsRequest) Pad() uint8 {
	offset := this.PadOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowStatsRequest) SetPad(p uint8) {
	offset := this.PadOffset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this *FlowStatsRequest) PadOffset() int {
	offset := 53
	return offset
}

func (this *FlowStatsRequest) OutPort() uint16 {
	offset := this.OutPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStatsRequest) SetOutPort(o uint16) {
	offset := this.OutPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], o)
	offset += 2
}

func (this *FlowStatsRequest) OutPortOffset() int {
	offset := 54
	return offset
}

func NewFlowStatsWithBuf(b []byte) FlowStats {
	return FlowStats{packet.Packet{Buf: b}}
}

func NewFlowStats() FlowStats {
	s := 88
	b := make([]byte, s)
	p := FlowStats{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type FlowStats struct {
	packet.Packet
}

func (this FlowStats) minSize() int {
	return 88
}

func (this FlowStats) Clone() (FlowStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowStats(), err
	}

	return NewFlowStatsWithBuf(newBuf.Bytes()), nil
}

type FlowStatsConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFlowStatsConn(c net.Conn) FlowStatsConn {
	return FlowStatsConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowStatsConn) Write(pkts []FlowStats) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *FlowStatsConn) Read(pkts []FlowStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowStatsWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *FlowStats) Init() {
	this.SetLength(uint16(this.minSize()))
	// Invariants.
}

func (this FlowStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowStats(p packet.Packet) (FlowStats, error) {
	if !IsFlowStats(p) {
		return NewFlowStatsWithBuf(nil), errors.New("Cannot convert to of10.FlowStats")
	}

	return NewFlowStatsWithBuf(p.Buf), nil
}

func IsFlowStats(p packet.Packet) bool {
	return true
}

func (this *FlowStats) Length() uint16 {
	offset := this.LengthOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetLength(l uint16) {
	offset := this.LengthOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this *FlowStats) LengthOffset() int {
	offset := 0
	return offset
}

func (this *FlowStats) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowStats) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this *FlowStats) TableIdOffset() int {
	offset := 2
	return offset
}

func (this *FlowStats) Pad() uint8 {
	offset := this.PadOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *FlowStats) SetPad(p uint8) {
	offset := this.PadOffset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this *FlowStats) PadOffset() int {
	offset := 3
	return offset
}

func (this *FlowStats) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetMatch(m Match) {
	offset := this.MatchOffset()
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this *FlowStats) MatchOffset() int {
	offset := 4
	return offset
}

func (this *FlowStats) DurationSec() uint32 {
	offset := this.DurationSecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetDurationSec(d uint32) {
	offset := this.DurationSecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this *FlowStats) DurationSecOffset() int {
	offset := 44
	return offset
}

func (this *FlowStats) DurationNsec() uint32 {
	offset := this.DurationNsecOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetDurationNsec(d uint32) {
	offset := this.DurationNsecOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], d)
	offset += 4
}

func (this *FlowStats) DurationNsecOffset() int {
	offset := 48
	return offset
}

func (this *FlowStats) Priority() uint16 {
	offset := this.PriorityOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetPriority(p uint16) {
	offset := this.PriorityOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *FlowStats) PriorityOffset() int {
	offset := 52
	return offset
}

func (this *FlowStats) IdleTimeout() uint16 {
	offset := this.IdleTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetIdleTimeout(i uint16) {
	offset := this.IdleTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], i)
	offset += 2
}

func (this *FlowStats) IdleTimeoutOffset() int {
	offset := 54
	return offset
}

func (this *FlowStats) HardTimeout() uint16 {
	offset := this.HardTimeoutOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetHardTimeout(h uint16) {
	offset := this.HardTimeoutOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], h)
	offset += 2
}

func (this *FlowStats) HardTimeoutOffset() int {
	offset := 56
	return offset
}

func (this *FlowStats) Pad2() [6]uint8 {
	offset := this.Pad2Offset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *FlowStats) SetPad2(p [6]uint8) {
	offset := this.Pad2Offset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *FlowStats) Pad2Offset() int {
	offset := 58
	return offset
}

func (this *FlowStats) Cookie() uint64 {
	offset := this.CookieOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetCookie(c uint64) {
	offset := this.CookieOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this *FlowStats) CookieOffset() int {
	offset := 64
	return offset
}

func (this *FlowStats) PacketCount() uint64 {
	offset := this.PacketCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetPacketCount(p uint64) {
	offset := this.PacketCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], p)
	offset += 8
}

func (this *FlowStats) PacketCountOffset() int {
	offset := 72
	return offset
}

func (this *FlowStats) ByteCount() uint64 {
	offset := this.ByteCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *FlowStats) SetByteCount(b uint64) {
	offset := this.ByteCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], b)
	offset += 8
}

func (this *FlowStats) ByteCountOffset() int {
	offset := 80
	return offset
}

func (this *FlowStats) Actions() []ActionHeader {
	offset := this.ActionsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []ActionHeader
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewActionHeaderWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FlowStats) AddActions(a ActionHeader) {
	offset := this.ActionsOffset()
	offset += this.ActionsSize()
	size := a.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], a.Buf[:a.Size()])
	offset += a.Size()
}

func (this *FlowStats) ActionsOffset() int {
	offset := 88
	return offset
}

func (this *FlowStats) ActionsSize() int {
	offset := this.ActionsOffset()
	return this.Size() - offset
}

func NewFlowStatsReplyWithBuf(b []byte) FlowStatsReply {
	return FlowStatsReply{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
}

func NewFlowStatsReply() FlowStatsReply {
	s := 12
	b := make([]byte, s)
	p := FlowStatsReply{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type FlowStatsReply struct {
	StatsReply
}

func (this FlowStatsReply) minSize() int {
	return 12
}

func (this FlowStatsReply) Clone() (FlowStatsReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewFlowStatsReply(), err
	}

	return NewFlowStatsReplyWithBuf(newBuf.Bytes()), nil
}

type FlowStatsReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewFlowStatsReplyConn(c net.Conn) FlowStatsReplyConn {
	return FlowStatsReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *FlowStatsReplyConn) Write(pkts []FlowStatsReply) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *FlowStatsReplyConn) Read(pkts []FlowStatsReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewFlowStatsReplyWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *FlowStatsReply) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(1)) // stats_type
	this.SetType(uint8(17))      // type
	this.SetVersion(uint8(1))    // version
}

func (this FlowStatsReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToFlowStatsReply(p StatsReply) (FlowStatsReply, error) {
	if !IsFlowStatsReply(p) {
		return NewFlowStatsReplyWithBuf(nil), errors.New("Cannot convert to of10.FlowStatsReply")
	}

	return NewFlowStatsReplyWithBuf(p.Buf), nil
}

func IsFlowStatsReply(p StatsReply) bool {
	return p.StatsType() == 1 && true
}

func (this *FlowStatsReply) FlowStats() []FlowStats {
	offset := this.FlowStatsOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []FlowStats
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewFlowStatsWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *FlowStatsReply) AddFlowStats(f FlowStats) {
	offset := this.FlowStatsOffset()
	offset += this.FlowStatsSize()
	size := f.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], f.Buf[:f.Size()])
	offset += f.Size()
}

func (this *FlowStatsReply) FlowStatsOffset() int {
	offset := 12
	return offset
}

func (this *FlowStatsReply) FlowStatsSize() int {
	offset := this.FlowStatsOffset()
	return this.Size() - offset
}

func NewAggregateStatsRequestWithBuf(b []byte) AggregateStatsRequest {
	return AggregateStatsRequest{StatsRequest{Header10{of.Header{packet.Packet{Buf: b}}}}}
}

func NewAggregateStatsRequest() AggregateStatsRequest {
	s := 56
	b := make([]byte, s)
	p := AggregateStatsRequest{StatsRequest{Header10{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type AggregateStatsRequest struct {
	StatsRequest
}

func (this AggregateStatsRequest) minSize() int {
	return 56
}

func (this AggregateStatsRequest) Clone() (AggregateStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewAggregateStatsRequest(), err
	}

	return NewAggregateStatsRequestWithBuf(newBuf.Bytes()), nil
}

type AggregateStatsRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewAggregateStatsRequestConn(c net.Conn) AggregateStatsRequestConn {
	return AggregateStatsRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *AggregateStatsRequestConn) Write(pkts []AggregateStatsRequest) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *AggregateStatsRequestConn) Read(pkts []AggregateStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewAggregateStatsRequestWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *AggregateStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(2)) // stats_type
	this.SetType(uint8(16))      // type
	this.SetVersion(uint8(1))    // version
}

func (this AggregateStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToAggregateStatsRequest(p StatsRequest) (AggregateStatsRequest, error) {
	if !IsAggregateStatsRequest(p) {
		return NewAggregateStatsRequestWithBuf(nil), errors.New("Cannot convert to of10.AggregateStatsRequest")
	}

	return NewAggregateStatsRequestWithBuf(p.Buf), nil
}

func IsAggregateStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 2 && true
}

func (this *AggregateStatsRequest) Match() Match {
	offset := this.MatchOffset()
	res := NewMatchWithBuf(this.Buf[offset:])
	return res
}

func (this *AggregateStatsRequest) SetMatch(m Match) {
	offset := this.MatchOffset()
	copy(this.Buf[offset:], m.Buf[:m.Size()])
	offset += m.Size()
}

func (this *AggregateStatsRequest) MatchOffset() int {
	offset := 12
	return offset
}

func (this *AggregateStatsRequest) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *AggregateStatsRequest) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this *AggregateStatsRequest) TableIdOffset() int {
	offset := 52
	return offset
}

func (this *AggregateStatsRequest) Pad() uint8 {
	offset := this.PadOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *AggregateStatsRequest) SetPad(p uint8) {
	offset := this.PadOffset()
	this.Buf[offset] = byte(p)
	offset++
}

func (this *AggregateStatsRequest) PadOffset() int {
	offset := 53
	return offset
}

func (this *AggregateStatsRequest) OutPort() uint16 {
	offset := this.OutPortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *AggregateStatsRequest) SetOutPort(o uint16) {
	offset := this.OutPortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], o)
	offset += 2
}

func (this *AggregateStatsRequest) OutPortOffset() int {
	offset := 54
	return offset
}

func NewAggregateStatsReplyWithBuf(b []byte) AggregateStatsReply {
	return AggregateStatsReply{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
}

func NewAggregateStatsReply() AggregateStatsReply {
	s := 36
	b := make([]byte, s)
	p := AggregateStatsReply{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type AggregateStatsReply struct {
	StatsReply
}

func (this AggregateStatsReply) minSize() int {
	return 36
}

func (this AggregateStatsReply) Clone() (AggregateStatsReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewAggregateStatsReply(), err
	}

	return NewAggregateStatsReplyWithBuf(newBuf.Bytes()), nil
}

type AggregateStatsReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewAggregateStatsReplyConn(c net.Conn) AggregateStatsReplyConn {
	return AggregateStatsReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *AggregateStatsReplyConn) Write(pkts []AggregateStatsReply) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *AggregateStatsReplyConn) Read(pkts []AggregateStatsReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewAggregateStatsReplyWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *AggregateStatsReply) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(2)) // stats_type
	this.SetType(uint8(17))      // type
	this.SetVersion(uint8(1))    // version
}

func (this AggregateStatsReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToAggregateStatsReply(p StatsReply) (AggregateStatsReply, error) {
	if !IsAggregateStatsReply(p) {
		return NewAggregateStatsReplyWithBuf(nil), errors.New("Cannot convert to of10.AggregateStatsReply")
	}

	return NewAggregateStatsReplyWithBuf(p.Buf), nil
}

func IsAggregateStatsReply(p StatsReply) bool {
	return p.StatsType() == 2 && true
}

func (this *AggregateStatsReply) PacketCount() uint64 {
	offset := this.PacketCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *AggregateStatsReply) SetPacketCount(p uint64) {
	offset := this.PacketCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], p)
	offset += 8
}

func (this *AggregateStatsReply) PacketCountOffset() int {
	offset := 12
	return offset
}

func (this *AggregateStatsReply) ByteCount() uint64 {
	offset := this.ByteCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *AggregateStatsReply) SetByteCount(b uint64) {
	offset := this.ByteCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], b)
	offset += 8
}

func (this *AggregateStatsReply) ByteCountOffset() int {
	offset := 20
	return offset
}

func (this *AggregateStatsReply) FlowCount() uint32 {
	offset := this.FlowCountOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *AggregateStatsReply) SetFlowCount(f uint32) {
	offset := this.FlowCountOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], f)
	offset += 4
}

func (this *AggregateStatsReply) FlowCountOffset() int {
	offset := 28
	return offset
}

func (this *AggregateStatsReply) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *AggregateStatsReply) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *AggregateStatsReply) PadOffset() int {
	offset := 32
	return offset
}

func NewTableStatsWithBuf(b []byte) TableStats {
	return TableStats{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
}

func NewTableStats() TableStats {
	s := 76
	b := make([]byte, s)
	p := TableStats{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type TableStats struct {
	StatsReply
}

func (this TableStats) minSize() int {
	return 76
}

func (this TableStats) Clone() (TableStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewTableStats(), err
	}

	return NewTableStatsWithBuf(newBuf.Bytes()), nil
}

type TableStatsConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewTableStatsConn(c net.Conn) TableStatsConn {
	return TableStatsConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *TableStatsConn) Write(pkts []TableStats) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *TableStatsConn) Read(pkts []TableStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewTableStatsWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *TableStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(3)) // stats_type
	this.SetType(uint8(17))      // type
	this.SetVersion(uint8(1))    // version
}

func (this TableStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToTableStats(p StatsReply) (TableStats, error) {
	if !IsTableStats(p) {
		return NewTableStatsWithBuf(nil), errors.New("Cannot convert to of10.TableStats")
	}

	return NewTableStatsWithBuf(p.Buf), nil
}

func IsTableStats(p StatsReply) bool {
	return p.StatsType() == 3 && true
}

func (this *TableStats) TableId() uint8 {
	offset := this.TableIdOffset()
	res := uint8(this.Buf[offset])
	return res
}

func (this *TableStats) SetTableId(t uint8) {
	offset := this.TableIdOffset()
	this.Buf[offset] = byte(t)
	offset++
}

func (this *TableStats) TableIdOffset() int {
	offset := 12
	return offset
}

func (this *TableStats) Pad() [3]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 3
	i := 0
	var res [3]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *TableStats) SetPad(p [3]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *TableStats) PadOffset() int {
	offset := 13
	return offset
}

func (this *TableStats) Name() [32]byte {
	offset := this.NameOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 32
	i := 0
	var res [32]byte
	for size > 0 && count > 0 && packet_size > offset {
		elem := byte(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *TableStats) SetName(n [32]byte) {
	offset := this.NameOffset()
	for _, e := range n {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *TableStats) NameOffset() int {
	offset := 16
	return offset
}

func (this *TableStats) Wildcards() uint32 {
	offset := this.WildcardsOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *TableStats) SetWildcards(w uint32) {
	offset := this.WildcardsOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], w)
	offset += 4
}

func (this *TableStats) WildcardsOffset() int {
	offset := 48
	return offset
}

func (this *TableStats) MaxEntries() uint32 {
	offset := this.MaxEntriesOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *TableStats) SetMaxEntries(m uint32) {
	offset := this.MaxEntriesOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], m)
	offset += 4
}

func (this *TableStats) MaxEntriesOffset() int {
	offset := 52
	return offset
}

func (this *TableStats) ActiveCount() uint32 {
	offset := this.ActiveCountOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *TableStats) SetActiveCount(a uint32) {
	offset := this.ActiveCountOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], a)
	offset += 4
}

func (this *TableStats) ActiveCountOffset() int {
	offset := 56
	return offset
}

func (this *TableStats) LookupCount() uint64 {
	offset := this.LookupCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *TableStats) SetLookupCount(l uint64) {
	offset := this.LookupCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], l)
	offset += 8
}

func (this *TableStats) LookupCountOffset() int {
	offset := 60
	return offset
}

func (this *TableStats) MatchedCount() uint64 {
	offset := this.MatchedCountOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *TableStats) SetMatchedCount(m uint64) {
	offset := this.MatchedCountOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], m)
	offset += 8
}

func (this *TableStats) MatchedCountOffset() int {
	offset := 68
	return offset
}

func NewPortStatsRequestWithBuf(b []byte) PortStatsRequest {
	return PortStatsRequest{StatsRequest{Header10{of.Header{packet.Packet{Buf: b}}}}}
}

func NewPortStatsRequest() PortStatsRequest {
	s := 20
	b := make([]byte, s)
	p := PortStatsRequest{StatsRequest{Header10{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type PortStatsRequest struct {
	StatsRequest
}

func (this PortStatsRequest) minSize() int {
	return 20
}

func (this PortStatsRequest) Clone() (PortStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortStatsRequest(), err
	}

	return NewPortStatsRequestWithBuf(newBuf.Bytes()), nil
}

type PortStatsRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPortStatsRequestConn(c net.Conn) PortStatsRequestConn {
	return PortStatsRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortStatsRequestConn) Write(pkts []PortStatsRequest) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *PortStatsRequestConn) Read(pkts []PortStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortStatsRequestWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *PortStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(4)) // stats_type
	this.SetType(uint8(16))      // type
	this.SetVersion(uint8(1))    // version
}

func (this PortStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortStatsRequest(p StatsRequest) (PortStatsRequest, error) {
	if !IsPortStatsRequest(p) {
		return NewPortStatsRequestWithBuf(nil), errors.New("Cannot convert to of10.PortStatsRequest")
	}

	return NewPortStatsRequestWithBuf(p.Buf), nil
}

func IsPortStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 4 && true
}

func (this *PortStatsRequest) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PortStatsRequest) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *PortStatsRequest) PortNoOffset() int {
	offset := 12
	return offset
}

func (this *PortStatsRequest) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortStatsRequest) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PortStatsRequest) PadOffset() int {
	offset := 14
	return offset
}

func NewPortStatsWithBuf(b []byte) PortStats {
	return PortStats{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
}

func NewPortStats() PortStats {
	s := 116
	b := make([]byte, s)
	p := PortStats{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type PortStats struct {
	StatsReply
}

func (this PortStats) minSize() int {
	return 116
}

func (this PortStats) Clone() (PortStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPortStats(), err
	}

	return NewPortStatsWithBuf(newBuf.Bytes()), nil
}

type PortStatsConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPortStatsConn(c net.Conn) PortStatsConn {
	return PortStatsConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PortStatsConn) Write(pkts []PortStats) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *PortStatsConn) Read(pkts []PortStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPortStatsWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *PortStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(4)) // stats_type
	this.SetType(uint8(17))      // type
	this.SetVersion(uint8(1))    // version
}

func (this PortStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToPortStats(p StatsReply) (PortStats, error) {
	if !IsPortStats(p) {
		return NewPortStatsWithBuf(nil), errors.New("Cannot convert to of10.PortStats")
	}

	return NewPortStatsWithBuf(p.Buf), nil
}

func IsPortStats(p StatsReply) bool {
	return p.StatsType() == 4 && true
}

func (this *PortStats) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PortStats) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *PortStats) PortNoOffset() int {
	offset := 12
	return offset
}

func (this *PortStats) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PortStats) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PortStats) PadOffset() int {
	offset := 14
	return offset
}

func (this *PortStats) RxPackets() uint64 {
	offset := this.RxPacketsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxPackets(r uint64) {
	offset := this.RxPacketsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxPacketsOffset() int {
	offset := 20
	return offset
}

func (this *PortStats) TxPackets() uint64 {
	offset := this.TxPacketsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxPackets(t uint64) {
	offset := this.TxPacketsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *PortStats) TxPacketsOffset() int {
	offset := 28
	return offset
}

func (this *PortStats) RxBytes() uint64 {
	offset := this.RxBytesOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxBytes(r uint64) {
	offset := this.RxBytesOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxBytesOffset() int {
	offset := 36
	return offset
}

func (this *PortStats) TxBytes() uint64 {
	offset := this.TxBytesOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxBytes(t uint64) {
	offset := this.TxBytesOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *PortStats) TxBytesOffset() int {
	offset := 44
	return offset
}

func (this *PortStats) RxDropped() uint64 {
	offset := this.RxDroppedOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxDropped(r uint64) {
	offset := this.RxDroppedOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxDroppedOffset() int {
	offset := 52
	return offset
}

func (this *PortStats) TxDropped() uint64 {
	offset := this.TxDroppedOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxDropped(t uint64) {
	offset := this.TxDroppedOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *PortStats) TxDroppedOffset() int {
	offset := 60
	return offset
}

func (this *PortStats) RxErrors() uint64 {
	offset := this.RxErrorsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxErrors(r uint64) {
	offset := this.RxErrorsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxErrorsOffset() int {
	offset := 68
	return offset
}

func (this *PortStats) TxErrors() uint64 {
	offset := this.TxErrorsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetTxErrors(t uint64) {
	offset := this.TxErrorsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *PortStats) TxErrorsOffset() int {
	offset := 76
	return offset
}

func (this *PortStats) RxFrameErr() uint64 {
	offset := this.RxFrameErrOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxFrameErr(r uint64) {
	offset := this.RxFrameErrOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxFrameErrOffset() int {
	offset := 84
	return offset
}

func (this *PortStats) RxOverErr() uint64 {
	offset := this.RxOverErrOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxOverErr(r uint64) {
	offset := this.RxOverErrOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxOverErrOffset() int {
	offset := 92
	return offset
}

func (this *PortStats) RxCrcErr() uint64 {
	offset := this.RxCrcErrOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetRxCrcErr(r uint64) {
	offset := this.RxCrcErrOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], r)
	offset += 8
}

func (this *PortStats) RxCrcErrOffset() int {
	offset := 100
	return offset
}

func (this *PortStats) Collisions() uint64 {
	offset := this.CollisionsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *PortStats) SetCollisions(c uint64) {
	offset := this.CollisionsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], c)
	offset += 8
}

func (this *PortStats) CollisionsOffset() int {
	offset := 108
	return offset
}

func NewVendorHeaderWithBuf(b []byte) VendorHeader {
	return VendorHeader{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewVendorHeader() VendorHeader {
	s := 12
	b := make([]byte, s)
	p := VendorHeader{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type VendorHeader struct {
	Header10
}

func (this VendorHeader) minSize() int {
	return 12
}

func (this VendorHeader) Clone() (VendorHeader, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewVendorHeader(), err
	}

	return NewVendorHeaderWithBuf(newBuf.Bytes()), nil
}

type VendorHeaderConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewVendorHeaderConn(c net.Conn) VendorHeaderConn {
	return VendorHeaderConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *VendorHeaderConn) Write(pkts []VendorHeader) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *VendorHeaderConn) Read(pkts []VendorHeader) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewVendorHeaderWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *VendorHeader) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(4))    // type
	this.SetVersion(uint8(1)) // version
}

func (this VendorHeader) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToVendorHeader(p Header10) (VendorHeader, error) {
	if !IsVendorHeader(p) {
		return NewVendorHeaderWithBuf(nil), errors.New("Cannot convert to of10.VendorHeader")
	}

	return NewVendorHeaderWithBuf(p.Buf), nil
}

func IsVendorHeader(p Header10) bool {
	return p.Type() == 4 && true
}

func (this *VendorHeader) Vendor() uint32 {
	offset := this.VendorOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *VendorHeader) SetVendor(v uint32) {
	offset := this.VendorOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], v)
	offset += 4
}

func (this *VendorHeader) VendorOffset() int {
	offset := 8
	return offset
}

func NewQueuePropHeaderWithBuf(b []byte) QueuePropHeader {
	return QueuePropHeader{packet.Packet{Buf: b}}
}

func NewQueuePropHeader() QueuePropHeader {
	s := 8
	b := make([]byte, s)
	p := QueuePropHeader{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type QueuePropHeader struct {
	packet.Packet
}

func (this QueuePropHeader) minSize() int {
	return 8
}

func (this QueuePropHeader) Clone() (QueuePropHeader, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueuePropHeader(), err
	}

	return NewQueuePropHeaderWithBuf(newBuf.Bytes()), nil
}

type QueuePropHeaderConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueuePropHeaderConn(c net.Conn) QueuePropHeaderConn {
	return QueuePropHeaderConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueuePropHeaderConn) Write(pkts []QueuePropHeader) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *QueuePropHeaderConn) Read(pkts []QueuePropHeader) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueuePropHeaderWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *QueuePropHeader) Init() {
	this.SetLen(uint16(this.minSize()))
	// Invariants.
}

func (this QueuePropHeader) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToQueuePropHeader(p packet.Packet) (QueuePropHeader, error) {
	if !IsQueuePropHeader(p) {
		return NewQueuePropHeaderWithBuf(nil), errors.New("Cannot convert to of10.QueuePropHeader")
	}

	return NewQueuePropHeaderWithBuf(p.Buf), nil
}

func IsQueuePropHeader(p packet.Packet) bool {
	return true
}

func (this *QueuePropHeader) Property() uint16 {
	offset := this.PropertyOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueuePropHeader) SetProperty(p uint16) {
	offset := this.PropertyOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *QueuePropHeader) PropertyOffset() int {
	offset := 0
	return offset
}

func (this *QueuePropHeader) Len() uint16 {
	offset := this.LenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueuePropHeader) SetLen(l uint16) {
	offset := this.LenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this *QueuePropHeader) LenOffset() int {
	offset := 2
	return offset
}

func (this *QueuePropHeader) Pad() [4]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 4
	i := 0
	var res [4]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueuePropHeader) SetPad(p [4]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *QueuePropHeader) PadOffset() int {
	offset := 4
	return offset
}

func NewQueuePropMinRateWithBuf(b []byte) QueuePropMinRate {
	return QueuePropMinRate{QueuePropHeader{packet.Packet{Buf: b}}}
}

func NewQueuePropMinRate() QueuePropMinRate {
	s := 16
	b := make([]byte, s)
	p := QueuePropMinRate{QueuePropHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type QueuePropMinRate struct {
	QueuePropHeader
}

func (this QueuePropMinRate) minSize() int {
	return 16
}

func (this QueuePropMinRate) Clone() (QueuePropMinRate, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueuePropMinRate(), err
	}

	return NewQueuePropMinRateWithBuf(newBuf.Bytes()), nil
}

type QueuePropMinRateConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueuePropMinRateConn(c net.Conn) QueuePropMinRateConn {
	return QueuePropMinRateConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueuePropMinRateConn) Write(pkts []QueuePropMinRate) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *QueuePropMinRateConn) Read(pkts []QueuePropMinRate) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueuePropMinRateWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *QueuePropMinRate) Init() {
	this.QueuePropHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetProperty(uint16(1)) // property
}

func (this QueuePropMinRate) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToQueuePropMinRate(p QueuePropHeader) (QueuePropMinRate, error) {
	if !IsQueuePropMinRate(p) {
		return NewQueuePropMinRateWithBuf(nil), errors.New("Cannot convert to of10.QueuePropMinRate")
	}

	return NewQueuePropMinRateWithBuf(p.Buf), nil
}

func IsQueuePropMinRate(p QueuePropHeader) bool {
	return p.Property() == 1 && true
}

func (this *QueuePropMinRate) Rate() uint16 {
	offset := this.RateOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueuePropMinRate) SetRate(r uint16) {
	offset := this.RateOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], r)
	offset += 2
}

func (this *QueuePropMinRate) RateOffset() int {
	offset := 8
	return offset
}

func (this *QueuePropMinRate) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueuePropMinRate) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *QueuePropMinRate) PadOffset() int {
	offset := 10
	return offset
}

func NewPacketQueueWithBuf(b []byte) PacketQueue {
	return PacketQueue{packet.Packet{Buf: b}}
}

func NewPacketQueue() PacketQueue {
	s := 8
	b := make([]byte, s)
	p := PacketQueue{packet.Packet{Buf: b}}
	p.Init()
	return p
}

type PacketQueue struct {
	packet.Packet
}

func (this PacketQueue) minSize() int {
	return 8
}

func (this PacketQueue) Clone() (PacketQueue, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewPacketQueue(), err
	}

	return NewPacketQueueWithBuf(newBuf.Bytes()), nil
}

type PacketQueueConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewPacketQueueConn(c net.Conn) PacketQueueConn {
	return PacketQueueConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *PacketQueueConn) Write(pkts []PacketQueue) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *PacketQueueConn) Read(pkts []PacketQueue) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewPacketQueueWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *PacketQueue) Init() {
	this.SetLen(uint16(this.minSize()))
	// Invariants.
}

func (this PacketQueue) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToPacketQueue(p packet.Packet) (PacketQueue, error) {
	if !IsPacketQueue(p) {
		return NewPacketQueueWithBuf(nil), errors.New("Cannot convert to of10.PacketQueue")
	}

	return NewPacketQueueWithBuf(p.Buf), nil
}

func IsPacketQueue(p packet.Packet) bool {
	return true
}

func (this *PacketQueue) QueueId() uint32 {
	offset := this.QueueIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *PacketQueue) SetQueueId(q uint32) {
	offset := this.QueueIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], q)
	offset += 4
}

func (this *PacketQueue) QueueIdOffset() int {
	offset := 0
	return offset
}

func (this *PacketQueue) Len() uint16 {
	offset := this.LenOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *PacketQueue) SetLen(l uint16) {
	offset := this.LenOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], l)
	offset += 2
}

func (this *PacketQueue) LenOffset() int {
	offset := 4
	return offset
}

func (this *PacketQueue) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *PacketQueue) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *PacketQueue) PadOffset() int {
	offset := 6
	return offset
}

func (this *PacketQueue) Properties() []QueuePropHeader {
	offset := this.PropertiesOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []QueuePropHeader
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewQueuePropHeaderWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *PacketQueue) AddProperties(p QueuePropHeader) {
	offset := this.PropertiesOffset()
	offset += this.PropertiesSize()
	size := p.Size()
	this.OpenGap(offset, size)
	this.SetLen(uint16(this.Size() + size))
	copy(this.Buf[offset:], p.Buf[:p.Size()])
	offset += p.Size()
}

func (this *PacketQueue) PropertiesOffset() int {
	offset := 8
	return offset
}

func (this *PacketQueue) PropertiesSize() int {
	offset := this.PropertiesOffset()
	return this.Size() - offset
}

func NewQueueGetConfigRequestWithBuf(b []byte) QueueGetConfigRequest {
	return QueueGetConfigRequest{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewQueueGetConfigRequest() QueueGetConfigRequest {
	s := 10
	b := make([]byte, s)
	p := QueueGetConfigRequest{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type QueueGetConfigRequest struct {
	Header10
}

func (this QueueGetConfigRequest) minSize() int {
	return 10
}

func (this QueueGetConfigRequest) Clone() (QueueGetConfigRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueGetConfigRequest(), err
	}

	return NewQueueGetConfigRequestWithBuf(newBuf.Bytes()), nil
}

type QueueGetConfigRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueueGetConfigRequestConn(c net.Conn) QueueGetConfigRequestConn {
	return QueueGetConfigRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueGetConfigRequestConn) Write(pkts []QueueGetConfigRequest) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *QueueGetConfigRequestConn) Read(pkts []QueueGetConfigRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueGetConfigRequestWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *QueueGetConfigRequest) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(21))   // type
	this.SetVersion(uint8(1)) // version
}

func (this QueueGetConfigRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueGetConfigRequest(p Header10) (QueueGetConfigRequest, error) {
	if !IsQueueGetConfigRequest(p) {
		return NewQueueGetConfigRequestWithBuf(nil), errors.New("Cannot convert to of10.QueueGetConfigRequest")
	}

	return NewQueueGetConfigRequestWithBuf(p.Buf), nil
}

func IsQueueGetConfigRequest(p Header10) bool {
	return p.Type() == 21 && true
}

func (this *QueueGetConfigRequest) Port() uint16 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueGetConfigRequest) SetPort(p uint16) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *QueueGetConfigRequest) PortOffset() int {
	offset := 8
	return offset
}

func (this *QueueGetConfigRequest) Pad() []uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res = append(res, elem)
	}
	return res
}

func (this *QueueGetConfigRequest) AddPad(p uint8) {
	offset := this.PadOffset()
	offset += 1
	size := 1
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	this.Buf[offset] = byte(p)
	offset++
}

func (this *QueueGetConfigRequest) PadOffset() int {
	offset := 10
	return offset
}

func (this *QueueGetConfigRequest) PadSize() int {
	offset := this.PadOffset()
	return this.Size() - offset
}

func NewQueueGetConfigReplyWithBuf(b []byte) QueueGetConfigReply {
	return QueueGetConfigReply{Header10{of.Header{packet.Packet{Buf: b}}}}
}

func NewQueueGetConfigReply() QueueGetConfigReply {
	s := 16
	b := make([]byte, s)
	p := QueueGetConfigReply{Header10{of.Header{packet.Packet{Buf: b}}}}
	p.Init()
	return p
}

type QueueGetConfigReply struct {
	Header10
}

func (this QueueGetConfigReply) minSize() int {
	return 16
}

func (this QueueGetConfigReply) Clone() (QueueGetConfigReply, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueGetConfigReply(), err
	}

	return NewQueueGetConfigReplyWithBuf(newBuf.Bytes()), nil
}

type QueueGetConfigReplyConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueueGetConfigReplyConn(c net.Conn) QueueGetConfigReplyConn {
	return QueueGetConfigReplyConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueGetConfigReplyConn) Write(pkts []QueueGetConfigReply) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *QueueGetConfigReplyConn) Read(pkts []QueueGetConfigReply) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueGetConfigReplyWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *QueueGetConfigReply) Init() {
	this.Header10.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint8(21))   // type
	this.SetVersion(uint8(1)) // version
}

func (this QueueGetConfigReply) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueGetConfigReply(p Header10) (QueueGetConfigReply, error) {
	if !IsQueueGetConfigReply(p) {
		return NewQueueGetConfigReplyWithBuf(nil), errors.New("Cannot convert to of10.QueueGetConfigReply")
	}

	return NewQueueGetConfigReplyWithBuf(p.Buf), nil
}

func IsQueueGetConfigReply(p Header10) bool {
	return p.Type() == 21 && true
}

func (this *QueueGetConfigReply) Port() uint16 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueGetConfigReply) SetPort(p uint16) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *QueueGetConfigReply) PortOffset() int {
	offset := 8
	return offset
}

func (this *QueueGetConfigReply) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueueGetConfigReply) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *QueueGetConfigReply) PadOffset() int {
	offset := 10
	return offset
}

func (this *QueueGetConfigReply) Queues() []PacketQueue {
	offset := this.QueuesOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := this.Size() - offset
	var res []PacketQueue
	for size > 0 && count > 0 && packet_size > offset {
		elem := NewPacketQueueWithBuf(this.Buf[offset:])
		if elem.Size() > size {
			break
		}
		size -= elem.Size()
		offset += elem.Size()
		count--
		res = append(res, elem)
	}
	return res
}

func (this *QueueGetConfigReply) AddQueues(q PacketQueue) {
	offset := this.QueuesOffset()
	offset += this.QueuesSize()
	size := q.Size()
	this.OpenGap(offset, size)
	this.SetLength(uint16(this.Size() + size))
	copy(this.Buf[offset:], q.Buf[:q.Size()])
	offset += q.Size()
}

func (this *QueueGetConfigReply) QueuesOffset() int {
	offset := 16
	return offset
}

func (this *QueueGetConfigReply) QueuesSize() int {
	offset := this.QueuesOffset()
	return this.Size() - offset
}

func NewActionEnqueueWithBuf(b []byte) ActionEnqueue {
	return ActionEnqueue{ActionHeader{packet.Packet{Buf: b}}}
}

func NewActionEnqueue() ActionEnqueue {
	s := 16
	b := make([]byte, s)
	p := ActionEnqueue{ActionHeader{packet.Packet{Buf: b}}}
	p.Init()
	return p
}

type ActionEnqueue struct {
	ActionHeader
}

func (this ActionEnqueue) minSize() int {
	return 16
}

func (this ActionEnqueue) Clone() (ActionEnqueue, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewActionEnqueue(), err
	}

	return NewActionEnqueueWithBuf(newBuf.Bytes()), nil
}

type ActionEnqueueConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewActionEnqueueConn(c net.Conn) ActionEnqueueConn {
	return ActionEnqueueConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *ActionEnqueueConn) Write(pkts []ActionEnqueue) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *ActionEnqueueConn) Read(pkts []ActionEnqueue) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewActionEnqueueWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *ActionEnqueue) Init() {
	this.ActionHeader.Init()
	this.SetLen(uint16(this.minSize()))
	// Invariants.
	this.SetType(uint16(11)) // type
}

func (this ActionEnqueue) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Len())
	return size
}

func ToActionEnqueue(p ActionHeader) (ActionEnqueue, error) {
	if !IsActionEnqueue(p) {
		return NewActionEnqueueWithBuf(nil), errors.New("Cannot convert to of10.ActionEnqueue")
	}

	return NewActionEnqueueWithBuf(p.Buf), nil
}

func IsActionEnqueue(p ActionHeader) bool {
	return p.Type() == 11 && true
}

func (this *ActionEnqueue) Port() uint16 {
	offset := this.PortOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *ActionEnqueue) SetPort(p uint16) {
	offset := this.PortOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *ActionEnqueue) PortOffset() int {
	offset := 4
	return offset
}

func (this *ActionEnqueue) Pad() [6]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 6
	i := 0
	var res [6]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *ActionEnqueue) SetPad(p [6]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *ActionEnqueue) PadOffset() int {
	offset := 6
	return offset
}

func (this *ActionEnqueue) QueueId() uint32 {
	offset := this.QueueIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *ActionEnqueue) SetQueueId(q uint32) {
	offset := this.QueueIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], q)
	offset += 4
}

func (this *ActionEnqueue) QueueIdOffset() int {
	offset := 12
	return offset
}

func NewQueueStatsRequestWithBuf(b []byte) QueueStatsRequest {
	return QueueStatsRequest{StatsRequest{Header10{of.Header{packet.Packet{Buf: b}}}}}
}

func NewQueueStatsRequest() QueueStatsRequest {
	s := 20
	b := make([]byte, s)
	p := QueueStatsRequest{StatsRequest{Header10{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type QueueStatsRequest struct {
	StatsRequest
}

func (this QueueStatsRequest) minSize() int {
	return 20
}

func (this QueueStatsRequest) Clone() (QueueStatsRequest, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueStatsRequest(), err
	}

	return NewQueueStatsRequestWithBuf(newBuf.Bytes()), nil
}

type QueueStatsRequestConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueueStatsRequestConn(c net.Conn) QueueStatsRequestConn {
	return QueueStatsRequestConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueStatsRequestConn) Write(pkts []QueueStatsRequest) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *QueueStatsRequestConn) Read(pkts []QueueStatsRequest) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueStatsRequestWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *QueueStatsRequest) Init() {
	this.StatsRequest.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(5)) // stats_type
	this.SetType(uint8(16))      // type
	this.SetVersion(uint8(1))    // version
}

func (this QueueStatsRequest) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueStatsRequest(p StatsRequest) (QueueStatsRequest, error) {
	if !IsQueueStatsRequest(p) {
		return NewQueueStatsRequestWithBuf(nil), errors.New("Cannot convert to of10.QueueStatsRequest")
	}

	return NewQueueStatsRequestWithBuf(p.Buf), nil
}

func IsQueueStatsRequest(p StatsRequest) bool {
	return p.StatsType() == 5 && true
}

func (this *QueueStatsRequest) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueStatsRequest) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *QueueStatsRequest) PortNoOffset() int {
	offset := 12
	return offset
}

func (this *QueueStatsRequest) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueueStatsRequest) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *QueueStatsRequest) PadOffset() int {
	offset := 14
	return offset
}

func (this *QueueStatsRequest) QueueId() uint32 {
	offset := this.QueueIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *QueueStatsRequest) SetQueueId(q uint32) {
	offset := this.QueueIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], q)
	offset += 4
}

func (this *QueueStatsRequest) QueueIdOffset() int {
	offset := 16
	return offset
}

func NewQueueStatsWithBuf(b []byte) QueueStats {
	return QueueStats{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
}

func NewQueueStats() QueueStats {
	s := 44
	b := make([]byte, s)
	p := QueueStats{StatsReply{Header10{of.Header{packet.Packet{Buf: b}}}}}
	p.Init()
	return p
}

type QueueStats struct {
	StatsReply
}

func (this QueueStats) minSize() int {
	return 44
}

func (this QueueStats) Clone() (QueueStats, error) {
	var newBuf bytes.Buffer
	_, err := io.CopyN(&newBuf, bytes.NewBuffer(this.Buf), int64(this.Size()))
	if err != nil {
		return NewQueueStats(), err
	}

	return NewQueueStatsWithBuf(newBuf.Bytes()), nil
}

type QueueStatsConn struct {
	net.Conn
	buf    []byte
	offset int
}

func NewQueueStatsConn(c net.Conn) QueueStatsConn {
	return QueueStatsConn{
		Conn: c,
		buf:  make([]byte, packet.DefaultBufSize),
	}
}

func (c *QueueStatsConn) Write(pkts []QueueStats) error {
	for _, p := range pkts {
		s := p.Size()
		b := p.Buffer()[:s]
		n := 0
		for s > 0 {
			var err error
			if n, err = c.Conn.Write(b); err != nil {
				return fmt.Errorf("Error in write: %v", err)
			}
			s -= n
		}
	}
	return nil
}

func (c *QueueStatsConn) Read(pkts []QueueStats) (int, error) {
	if len(c.buf) == c.offset {
		newSize := packet.DefaultBufSize
		if newSize < len(c.buf) {
			newSize = 2 * len(c.buf)
		}

		buf := make([]byte, newSize)
		copy(buf, c.buf[:c.offset])
		c.buf = buf
	}

	r, err := c.Conn.Read(c.buf[c.offset:])
	if err != nil {
		return 0, err
	}

	r += c.offset

	s := 0
	n := 0
	for i := range pkts {
		p := NewQueueStatsWithBuf(c.buf)

		pSize := p.Size()
		if r < s+pSize {
			break
		}

		pkts[i] = p
		s += pSize
		n++
	}

	c.offset = r - s
	if c.offset < 0 {
		panic("Invalid value for offset")
	}

	c.buf = c.buf[s:]
	if c.offset < len(c.buf) {
		return n, nil
	}

	buf := make([]byte, packet.DefaultBufSize)
	copy(buf, c.buf[:c.offset])
	c.buf = buf
	return n, nil
}

func (this *QueueStats) Init() {
	this.StatsReply.Init()
	this.SetLength(uint16(this.minSize()))
	// Invariants.
	this.SetStatsType(uint16(5)) // stats_type
	this.SetType(uint8(17))      // type
	this.SetVersion(uint8(1))    // version
}

func (this QueueStats) Size() int {
	if len(this.Buf) < this.minSize() {
		return 0
	}

	size := int(this.Length())
	return size
}

func ToQueueStats(p StatsReply) (QueueStats, error) {
	if !IsQueueStats(p) {
		return NewQueueStatsWithBuf(nil), errors.New("Cannot convert to of10.QueueStats")
	}

	return NewQueueStatsWithBuf(p.Buf), nil
}

func IsQueueStats(p StatsReply) bool {
	return p.StatsType() == 5 && true
}

func (this *QueueStats) PortNo() uint16 {
	offset := this.PortNoOffset()
	res := binary.BigEndian.Uint16(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetPortNo(p uint16) {
	offset := this.PortNoOffset()
	binary.BigEndian.PutUint16(this.Buf[offset:], p)
	offset += 2
}

func (this *QueueStats) PortNoOffset() int {
	offset := 12
	return offset
}

func (this *QueueStats) Pad() [2]uint8 {
	offset := this.PadOffset()
	packet_size := this.Size()
	size := packet_size - offset
	count := 2
	i := 0
	var res [2]uint8
	for size > 0 && count > 0 && packet_size > offset {
		elem := uint8(this.Buf[offset])
		if size < 1 {
			break
		}
		size -= 1
		offset += 1
		count--
		res[i] = elem
		i++
	}
	return res
}

func (this *QueueStats) SetPad(p [2]uint8) {
	offset := this.PadOffset()
	for _, e := range p {
		this.Buf[offset] = byte(e)
		offset++
	}
}

func (this *QueueStats) PadOffset() int {
	offset := 14
	return offset
}

func (this *QueueStats) QueueId() uint32 {
	offset := this.QueueIdOffset()
	res := binary.BigEndian.Uint32(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetQueueId(q uint32) {
	offset := this.QueueIdOffset()
	binary.BigEndian.PutUint32(this.Buf[offset:], q)
	offset += 4
}

func (this *QueueStats) QueueIdOffset() int {
	offset := 16
	return offset
}

func (this *QueueStats) TxBytes() uint64 {
	offset := this.TxBytesOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetTxBytes(t uint64) {
	offset := this.TxBytesOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *QueueStats) TxBytesOffset() int {
	offset := 20
	return offset
}

func (this *QueueStats) TxPackets() uint64 {
	offset := this.TxPacketsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetTxPackets(t uint64) {
	offset := this.TxPacketsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *QueueStats) TxPacketsOffset() int {
	offset := 28
	return offset
}

func (this *QueueStats) TxErrors() uint64 {
	offset := this.TxErrorsOffset()
	res := binary.BigEndian.Uint64(this.Buf[offset:])
	return res
}

func (this *QueueStats) SetTxErrors(t uint64) {
	offset := this.TxErrorsOffset()
	binary.BigEndian.PutUint64(this.Buf[offset:], t)
	offset += 8
}

func (this *QueueStats) TxErrorsOffset() int {
	offset := 36
	return offset
}
